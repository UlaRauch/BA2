%----------------------------------------------------------------
%
%  File    :  thesis.tex
%
%  Authors :  Keith Andrews, IICM, TU Graz, Austria
%             Manuel Koschuch, FH Campus Wien, Austria
%			  Sebastian Ukleja, FH Campus Wien, Austria
% 
%  Created :  22 Feb 96
% 
%  Changed :  14 Oct 2020
%
%  For suggestions and remarks write to: sebastian.ukleja@fh-campuswien.ac.at
% 
%----------------------------------------------------------------

% --- Setup for the document ------------------------------------

%Class for a book like style:
\documentclass[11pt,a4paper,oneside]{scrbook}
%For a more paper like style use this class instead:
%\documentclass[11pt,a4paper,oneside]{thesis}

%input encoding for windows in utf-8 needed for Ä,Ö,Ü etc..:
\usepackage[utf8]{inputenc}
%input encoding for linux:
%\usepackage[latin1]{inputenc}
%input encoding for mac:
%\usepackage[applemac]{inputenc}

\usepackage[english]{babel}
% for german use this line instead:
%\usepackage[ngerman]{babel}

%needed for font encoding
\usepackage[T1]{fontenc}

% want Arial? uncomment next two lines...
%\usepackage{uarial}
%\renewcommand{\familydefault}{\sfdefault}

%some formatting packages
\usepackage[bf,sf]{subfigure}
\renewcommand{\subfigtopskip}{0mm}
\renewcommand{\subfigcapmargin}{0mm}

%For better font resolution in pdf files
\usepackage{lmodern}

\usepackage{url}

%\usepackage{latexsym}

\usepackage{geometry} % define pagesize in more detail


\usepackage{colortbl} % define colored backgrounds for tables

\usepackage{courier} %for listings
\usepackage{listings} % nicer code formatting
\lstset{basicstyle=\ttfamily,breaklines=true}

\usepackage{graphicx}
  \pdfcompresslevel=9
  \pdfpageheight=297mm
  \pdfpagewidth=210mm
  \usepackage[         % hyperref should be last package loaded
    pdftex, 		   % needed for pdf compiling, DO NOT compile with LaTeX
    bookmarks,
    bookmarksnumbered,
    linktocpage,
    pagebackref,
    pdfview={Fit},
    pdfstartview={Fit},
    pdfpagemode=UseOutlines,                 % open bookmarks in Acrobat
  ]{hyperref}
\DeclareGraphicsExtensions{.pdf,.jpg,.png}
\usepackage{bookmark}

\usepackage[title]{appendix}

%paper format
\geometry{a4paper,left=30mm,right=25mm, top=30mm, bottom=30mm}

% --- Settings for header and footer ---------------------------------
\usepackage{scrlayer-scrpage}
\clearscrheadfoot
\pagestyle{scrheadings}
\automark{chapter}

%Left header shows chapter and chapter name, will not display on first chapter page use \ihead*{\leftmark} to show on every page
\ihead{\leftmark} 	
%\ohead*{\rightmark}	%optional right header
\ifoot*{Ursula Rauch}		%left footer shows student name
\ofoot*{\thepage}		%right footer shows pagination
%---------------------------------------------------------------------

%--- additional packages necessary for table in results --------------
\usepackage[xcdraw]{xcolor}
\usepackage{lscape}
%-------------------------------------------------------------------- 

\usepackage{xcolor}

%New colors defined below
\definecolor{codeorange}{rgb}{1.00,0.45,0.00}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{codeorange},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codegreen},
  basicstyle=\ttfamily\small,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}
\lstset{style=mystyle}


\lstdefinestyle{yaml}{
  backgroundcolor=\color{backcolour},
  keywordstyle=\color{codeorange},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codegreen},
  basicstyle=\ttfamily\small,
  rulecolor=\color{black},
  string=[s]{'}{'},
  stringstyle=\color{codegreen},
  comment=[l]{:},
  commentstyle=\color{black},
  morecomment=[l]{-}
  breakatwhitespace=false,
  breaklines=false,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
 }

%----------------------------

%Start of your document beginning with title page
\begin{document}


% --- Main Title Page ------------------------------------------------
\begin{titlepage}
\frontmatter

\begin{picture}(50,50)
\put(-70,40){\hbox{\includegraphics{images/logo.png}}}
\end{picture}

\vspace*{-5.8cm}

\begin{center}

\vspace{6.2cm}

\hspace*{-1.0cm} {\LARGE \textbf{The positioning of the OAuth2 client in a Microservice-based Architecture\\}}
\vspace{0.2cm}
\hspace*{-1.0cm} A comparison between the implementation of the OAuth2 client in the Gateway and in the frontend\\

\vspace{2.0cm}

\hspace*{-1.0cm} { \textbf{Bachelor Thesis\\}}

\vspace{0.65cm}

\hspace*{-1.0cm} Submitted in partial fulfillment of the requirements for the degree of \\

\vspace{0.65cm}

\hspace*{-1.0cm} \textbf{Bachelor of Science in Engineering\\}

\vspace{0.65cm}

\hspace*{-1.0cm} to the University of Applied Sciences FH Campus Wien \\
\vspace{0.2cm}
\hspace*{-1.0cm} Bachelor Degree Program: Computer Science and Digital Communications \\

\vspace{1.6cm}

\hspace*{-1.0cm} \textbf{Author:} \\
\vspace{0.2cm}
\hspace*{-1.0cm} Ursula Rauch \\

\vspace{0.7cm}

\hspace*{-1.0cm} \textbf{Student identification number:}\\
\vspace{0.2cm}
\hspace*{-1.0cm} 00514397 \\

\vspace{0.7cm}

\hspace*{-1.0cm} \textbf{Supervisor:} \\
\vspace{0.2cm}
\hspace*{-1.0cm} Leon Freudenthaler, BSc MSc \\

\vspace{0.7cm}

% Reviewer if needed
%\hspace*{-1.0cm} \textbf{Reviewer: (optional)} \\
%\vspace{0.2cm}
%\hspace*{-1.0cm} Title first name surname \\


\vspace{1.0cm}

\hspace*{-1.0cm} \textbf{Date:} \\
\vspace{0.2cm}
\hspace*{-1.0cm}!!!FEHLT NOCH!!! \\

\end{center}
\end{titlepage}

\newpage

\vspace*{16cm}
\setcounter{page}{1}

% --- Declaration of authorship ------------------------------------------
\hspace*{-0.7cm} \underline{Declaration of authorship:}\\\\
I declare that this Bachelor Thesis has been written by myself. I have not used any other than the listed sources, nor have I received any unauthorized help.\\\\
I hereby certify that I have not submitted this Bachelor Thesis in any form (to a reviewer for assessment) either in Austria or abroad.\\\\
Furthermore, I assure that the (printed and electronic) copies I have submitted are identical.
\\\\\\
Date: 15.01.2023 \hspace{6cm} Signature:\\

% --- English Abstract ----------------------------------------------------
\cleardoublepage
\chapter*{Abstract - FEHLT}
This thesis investigates different implementations of Authorization and Authentication with OpenID Connect (OIDC) and OAuth 2.0 (OAuth2) in a microservice architecture (MSA) environment...
% --- German Abstract ----------------------------------------------------
\cleardoublepage
\chapter*{Kurzfassung - FEHLT}
Diese Arbeit untersucht unterschiedliche Implementierungen von OpenID Connect (OIDC) bzw. OAuth 2.0 (OAuth2) im Kontext von \linebreak Microservice-Architekturen (MSA) ...

% --- Abbrevations ----------------------------------------------------
\chapter*{List of Abbreviations - CHECKEN}
\vspace{0.65cm}

\begin{table*}[htbp]
		\begin{tabular}{ll}
			!!!ALT! NICHT gebrauchte raushaun und manche noch konsequenter benutzen, z.b. AS und MA
			AS & Authorization Server \\
			BCP & Best Current Practice \\
			CRUD & Create Read Update Delete \\
			ECDSA & Elliptic Curve Digital Signature Algorithm \\
			ES256 & ECDSA SHA-256 \\
			HMAC & Hash-based Message Authentication Code \\
			HS256 & HMAC SHA-256 \\
			IANA & Internet Assigned Numbers Authority \\
			IETF & Internet Engineering Task Force \\
			JOSE & JavaScript Object Signing and Encryption \\
			JSON & JavaScript Object Notation \\
			JWE & JSON Web Encryption \\			
			JWS & JSON Web Signature \\
			JWT & JSON Web Token \\
			!!! MA & Monolithic Architecture \\			
			MSA & Microservice Architecture \\
			mTLS & mutual Transport Layer Security \\
			OIDC & OpenID Connect \\
			RFC & Request for Comments \\
			OP & OIDC Provider \\
			POC & Proof of Concept \\
			PoLP & Principle of least privilege \\
			RSA & Rivest-Shamir-Adelman \\
			%SAML & Secturity Asertion Markup Language \\
			SHA & Secure Hash Algorithm \\
			SSO & Single Sign-on \\
			XACML & Extensible Access Control Markup Language \\
		\end{tabular}
\end{table*}

\chapter*{Acknowledgement}
%
macht man das hier nicht?
wenn doch, an welcher stelle genau?

% --- Key terms ----------------------------------------------------
\newpage
\chapter*{Key Terms}
\vspace{0.65cm}

\begin{itemize}
	\setlength{\itemsep}{0pt}
	\item[] Authentication
	\item[] Authorization
	\item[] BFF
	\item[] Gateway
	\item[] JWT
	\item[] Microservice Architecture
	\item[] OAuth 2
	\item[] OpenID Connect
\end{itemize}

% --- Table of contents autogenerated ------------------------------------
\newpage
\tableofcontents
\thispagestyle{empty}

% --- Begin of Thesis ----------------------------------------------------
\mainmatter
 \chapter{Introduction - FORSCHUNGSFRAGE ETC. FEHLT}
\label{chap:intro}

!!! Einleitung allgemein, Forschungsfragen:

Die Rolle des Gateways für Authentifizierung und Autorisierung mit Oauth2 und OpenID
Connect in Microservice-basierten Architekturen. Das Gateway kann sowohl als OAuth2-Client,
als auch als Resource Server implementiert werden. Im ersten Fall muss das Gateway als Client einen Access Token vom Authorization Server beantragen und diesen an den Resource
Server, also einen dahinter liegenden Service weiterschicken. Wenn das Gateway selbst als
Resource Server implementiert ist, muss das Frontend als Client fungieren und den Access Token beschaffen.
//
Forschungsfrage:
Achtung, neue Forschungsfrage!
%Wie lassen sich beide Patterns mit Spring Boot implementieren? Welche Unterschiede gibt es
%zwischen den Varianten, z.B. in den Bereichen Performance, Sicherheit, Komplexität?

relevanz: hier erklären, dass die section authn+authz die relevanz deutlich macht.
keycloak ist open source, spring boot ist sehr populär und vereinfacht development, daher eine naheliegende wahl. 

\section{Related Work - FEHLT}
\label{sec:relwork}

% Chatterjee & Prince \cite{chatterjeeApplyingSpringSecurity2022} implementieren Spring Security mit Keycloak aber sie vergleichen nix, konkreter anwendungsfall.


% nguyen & baker 2019 novel approach -> spring security

Die geben keine details drüber inwieweit das ergebnis den specifications entspricht

% Floren
% BFF vergelich
 \section{Microservice-based vs Monolithic Architecture}
\label{sec:msa-mon}

The principle of microservices is usually explained by comparing it with the concept of a monolithic architecture. While a monolith is made in one piece of software which combines all necessary functionality, microservices are loosely coupled, separate applications that communicate between each other usually via REST APIs \cite{lewisMicroservices2014}. Figure \ref{fig:msa} illustrates this difference between MSA and monolithic architecture. 

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/microservices-monolith.png}
	\caption{Monolithic architecture vs. microservice-based architecture according to \cite{lewis_microservices_2014}, \cite{rauchAuthxmicroservicesurauchPdf2023}.}
	\label{fig:msa}
\end{figure}

The advantages of MSA, that made it more and more popular over the last years are, according to \cite{dragoniMicroservicesYesterdayToday2017}: independent testing, debugging and redeployment of a single service with a small code base, leading to shorter down-time than with MA, flexible scaling of single services without unneccessary reduplication of the whole system and flexibility in the choice of languages and frameworks between the single services, limited only by the communicative needs between them. MSA is also very suitable for containerization and the upcoming of technologies like Docker and Kubernetes has further contributed to the deployment flexibility of microservices \cite{pahlContainerizationPaaSCloud2015}.

On the other hand, MSA poses security challenges that will be addressed in the next section.

\section{Authentication and Authorization}
\label{sec:authx}

Authentication and Authorization are related concepts and often they only appear linked to each other, which might be the reason why the distinction between the two is not always so clear. This section gives a short introduction and explains how they are different from each other.

\subsection{Authentication}
\label{sub:authentication}
Authentication deals with the question of identity. Often it is crucial to know the identity of a user in order to decide if the user is allowed to access a specific resource. If this is the case it might also be important to know later, that this person has accessed the resource, for example if someone has misused their right to access the resource for another than the allowed purpose, like stolen or manipulated data. The process of authentication involves the information who someone is, for example during a login process this can be a user id, and also the prove that this information is correct. This prove can be in the form of something only this person knows, like a secret password, or something only this person has, like a code that can be sent to this persons phone number, or some unique attribute of this person, like biometric data \cite[pp. ~59ff]{siriwardenaAdvancedAPISecurity2020}. A combination of those is multifactor authentication and increases the level of security. Not only human persons need authentication, but also systems can posess a kind of id that identifies them and a prove in the form of a secret code, a token or a certificate. In any case, there must be a database that can be consulted to verify that this prove is valid, otherwise it would be of no value, but it is not necessary for the system that controls access to a resource to possess the database itself, it can delegate the whole business of user authentication to a different entity that functions as an identity provider (IP).

\subsection{Authorization}
\label{sub:authorization}
Authorization on the other hand is about permissions. Naturally, in order to decide if someone should be authorized to access a resource, this will often require knowing who this person is. But in theory this is not necessarily the case by definition. A person might earn the right to access a resource regardless of who they are, or they might be authorized because of certain attributes, as it is the case for example with many public toilets that are open only for certain genders. It doesn't matter at all what a person's name is or when they were born, but they are allowed to access the toilet resource only if they appear to have the correct gender attribute. But in other more complex systems, especially where security is a priority, authentication is crucial in the combination with authorization. Roles or attributes of persons or other systems are determined based on their identity and in a second step it can be verified if the role or attribute authorizes them to access the resource. A person with the intention to access a resource might be able to prove that they are who they say they are, but they might still not be authorized to access the resource. This too requires the consulting of data to know who is allowed to do what.

\subsection{The role of authentication and authorization in MSA}
\label{sub:auth-msa}

With the characteristics of MSA, authentication and authorization play an even more important role than ever, although Service oriented Architecture (SOA) and distributed systems already point in the same direction \cite{dragoniMicroservicesYesterdayToday2017}. The OWASP Top 10 API Security Risks \cite{OWASPTop10} for 2023 list again broken authentication and broken authorization on top.  The main security challenges related to MSA were identified by Dragoni et al. to be a large surface attack area, network complexity, trust and heterogeneity \cite{dragoniMicroservicesYesterdayToday2017}. While heterogeneity and especially trust might not always present to the same degree in all MSA systems, the large surface attack area and network complexity are inherent features in any MSA system compared to a monolithic architecture. Other authors have pointed out the necessity (and also the increasing adoption in the industry) of a zero trust policy for MSA, which means that each microservice considers all other microservices or actors as potentially hostile and therefore no service should trust any incoming request without verifying it's integrity, regardless of who the sender might be \cite{luSurveyMicroservicesTrust2023}, \cite{shmelevaHowMicroservicesAre}. Compared to a monolithic system, this makes the implementation and management of authentication and authorization in a MSA more complex. While from an end user's perspective the experience might not be different when they communicate with the MSA system via an API gateway, which hides the underlying complexity of the system. There are only a couple of entry points relevant to them \cite{shmelevaHowMicroservicesAre}. But inside the system, the situation is very different: Because each single service must expose at least one endpoint to be of use in the MSA system, the number of endpoints that have to be protected is at least equal to the number of services.

%!!! ALT - Neu formulieren
%As we have seen in the previous sections, when talking about security in microservices, both, authentication and authorization are considered to be among the most important topics. In this section, a clarification is given how the two concepts differ and what their role is in the context of MSA. % and they are also discussed the most in academic literature (wie isses mit grey lit.?) (Billawa et al.).\\

%!!! ALT Authentication and authorization, although they sound very similar, are two distinctive concepts and it is important to understand the difference between the two.
%!!! ALT To put it very shortly, authentication is about identity and authorization is about permissions. When someone authenticates, they usually provide a proof of the fact that what they say who they are is true. Identity can be proven with something they know (e.g., a secret password), something they have (like a phone number, to which a code can be sent), or something they are (like biometric data), or a combination of those (e.g. in two-factor authentication where a user gives their username and password, but the authentication is only complete when they also give a code that was sent to their phone number or e-mail address). Not only a person can prove their identity. A system can authenticate as well, for example with a secret or certificate or both. Authorization on the other hand deals with the question what a person or entity is allowed to do, for example where they can enter. Because this usually depends on who they are, in order to determine which permissions someone or something has, authentication is necessary first. Siriwardena \cite[p.~133]{siriwardena_advanced_2020} gives a visa control at a border as example: A person who wants to cross the border has to authenticate - their picture and/or fingerprint might be validated as truly belonging to that person, perhaps also by comparing to a database. This is authentication. Knowing who that person is does not get this person across the border, unless they have a visa. The visa has to be valid and not expired and can contain further details about what you are allowed to do in that country \cite[p.~133]{siriwardena_advanced_2020}.
%siehe auhc chocolate vs. fudge oauth.net/articles/authentication Justin Richer)\\

%vergleich mit monolithic a. -> Nic Jackson auch noch angeben? wegen den tokens warats
%!!! ALT Now, what is special about authentication and authorization in a MSA? In a monolithic architecture, when a user wants to access a resource, they authenticate with the system and might get back a session token, which can be sent with every subsequent request to the system. The token can then be validated inside the system, and it will know if this user has the necessary permission for the requested transaction. The same process becomes way more complex in MSA. While a monolithic application only has few entry points, a MSA has at least as many entry points as deployed services and each of them should be protected \cite{jackson_microservice_2019}, \cite{dragoni_microservices_2017}. When a requested resource or service does not sit inside the same system as the service where the user has authenticated themselves, the first service does not know if it can trust whoever made this request without either making another request to the server responsible for dealing with authentication and permissions, or having a way to validate the token locally, without further communication, which might not always be possible. This results in a higher number of requests between services and therefore in potentially decreased performance of the MSA.% \cite{siriwardena_microservices_2020}.\\

%!!! ALT To make everything worse, not only access by external end-users has to be managed, but also communication between services. Although the MSA principle demands loosely coupled microservices, it is sometimes inevitable that one service has to talk to another service in order to fulfil its job. But a service should not be reachable by any other microservices in the system, only by those who have a good reason to do so \cite{yarygina_overcoming_2018}. When a service talks to another service on behalf of a user, the user information (authentication and authorization) can be passed on down the line, so each microservice knows who they are working for. This is called principal propagation \cite{yarygina_overcoming_2018}.\\

%third-party access...

%oauth2+oidc hier schon ankündigen?



%\subsection{The API Gateway}
%\label{sec:UnterUnterkapitel22}
%Kommt wahrscheinlich raus, sonst hier anmerken, das das wichtig ist, aber in dieser Arbeit nicht weiter behandelt wird.\\

%While there exist different approaches to the implementation of API Gateways in MSA \cite{floren_implementation_2021}, authors seem to generally agree about the need of at least one API Gateway that stands between the client or end user and the backend microservices.!!!da noch wen zitieren? The beforementioned increased attack surface of an MSA can be reduced dramatically by creating a choke point for all requests  
%\end{comment}

\section{OAuth 2 and OpenID Connect}
\label{sec:oauth-oidc}

To begin with, OAuth 2 (OAuth2) is a framework or open protocol for authorization only. OAuth2 is considered the inofficial standard for securing the access to APIs \cite[p. ~81]{siriwardenaAdvancedAPISecurity2020}, \cite{barbettiniOAuthOpenIDConnect2018}. It does not deal with authentication, but authorization only. It has been described in Request for Comments (RFC) 6749 \cite{hardtOAuthAuthorizationFramework2012} and RFC 6750 \cite{jonesOAuthAuthorizationFramework2012}, followed by a long tail of further specifications \cite{dennissOAuthDeviceAuthorization2019}, \cite{jonesOAuthTokenExchange2020}, \cite{campbellResourceIndicatorsOAuth2020}, \cite{sakimuraOAuthAuthorizationFramework2021}, Security Considerations \cite{lodderstedtOAuthThreatModel2013}, \cite{sakimuraProofKeyCode2015} and a series of Security Best Current Practice Internet drafts \cite{2023}\footnote{This is not a comprehensive list.}. The original specifications from 2012 have been updated by RFC 8252, "OAuth 2.0 for Native Apps" \cite{dennissOAuthNativeApps2017} and by "OAuth 2.0 for Browser-Based Apps" \cite{pareckiOAuthBrowserBasedApps}. Since this is not even a comprehensive list, it is understandable that the new specification for OAuth 2.1 \cite{hardtOAuthAuthorizationFramework2023}, which has been published just recently, has been long awaited by some. It replaces RFC 6749 and 6750.

Because OAuth2 to is not intended to be used for authentication, OpenID connect (OIDC)\cite{sakimuraOpenIDConnectCore2014}  was created as a seperate layer for this purpose, in addition to OAuth2 in 2014. Therefore it should be clear that these two are not alternative concepts to choose from, but when securing services, both should be used.
% mehr details dazu in section xy?

\subsection{OAuth2}
\label{sub:oauth2}
The motivation for the creation of OAuth2 was to enable a client application to access a resource on a server on behalf of the owner of that resource without the need to pass on the resource owners credentials to this client for authentication \cite{hardtOAuthAuthorizationFramework2023}. Third-party access to resources is a very common practice, the standard example is an application that needs access to a user's facebook timeline \texttt[p. ~81]{siriwardenaAdvancedAPISecurity2020}, but it may as well be a different resource like pictures or a person's calendar. Sharing a password with a third-party application is undesireable for several reasons \cite{hardtOAuthAuthorizationFramework2023} : Passwords are inherently weak, especially in combination with human users, who tend to reuse passwords on different unrelated systems and servers would have to implement support for password authentication. Third-party applications would store these passwords, typically in clear-text. By authenticating with the server as the user, the third party application would have access to all of the user's data with the same permissions as the user themselve. The only way to revoke access for such an application would be to change the password, which would naturally exclude all other third-party applications as well.

OAuth2 separates the role of the \textit{client} (the third-party application) from the \textit{resource owner} (the end user who allows access to a resource to the client), so that the client is not required anymore to pretend to be the user by using the user's credentials when communicating with the \textit{resource server} (the server holding the resource). Instead of a password the client sends an \textit{access token} with every request to the resource server. This access token has a limited lifespan and other attributes that allow to control the extend to which the client can access the resources on that server. This access token is issued to the client by an \textit{authorization server} after the user has given consent for the client to access the resource. Following the principle of separation of concerns, the authorization server is also the only one dealing with authentication of the user \texttt{hardtOAuthAuthorizationFramework2023}.

The explicit consent of the resource owner for the client to access the resource is called \texttt{authorization grant}. The client can use this grant to obtain the access token from the authorization server. There are several different authentication grant flows defined for OAuth2. The preferred grant type for most use cases is the \textit{Authorization Code} grant type\footnote{Before OAuth 2.1 there was also the \textit{Implicit} grant and the \textit{Resource Owner Password Credentials} grant, but they are not considered secure anymore. Their use has already been excluded by OAuth 2.0 Securit Best Practice documents\cite{lodderstedtOAuthSecurityBest2023a} and they are completely omitted in the new specification \texttt{hardtOAuthAuthorizationFramework2023} (See also \cite{rauchAuthxmicroservicesurauchPdf2023}).} Other grant types are the \textit{Refresh Token} grant and the \texttt{Client Credentials} grant. With the \textit{Authorization Code} grant the authorization server issues first only a code to the user agent together with the redirect url. After the authentication, the user is sent back to the client by the authorization server with this redirect url and the authorization code. The client application can now send the code to a different endpoint at the authorization server, the \texttt{token endpoint}, and exchange it for an access token. In this way the access token is transmitted only via backchannel communication, which makes it harder for attackers to intercept the token. There are also additional measurements to make the code exchange more secure, like the \texttt{state} parameter and \textit{Proof Key for Code Exchange} (PKCE). When the client redirects the user agent to the authorization server (this is called the authorization request), it must create a code challenge and add it to the request, unless it is a confidential client and the OIDC \texttt{nonce} value is used. Other required parameters are the \texttt{response\_type} (\texttt{code} for the \texttt{authorization code grant}) and the \texttt{client\_id} \cite{hardtOAuthAuthorizationFramework2023}. Figure \ref{fig:auth-code-grant} shows the steps involved between the different roles during the authorization code grant flow.

%Stimmt nicht: OAuth 2.1 does not require...: It is also important to know that clients have to be registered with the authorization server in order to be able to authenticate later when requesting an access token\texttt{hardtOAuthAuthorizationFramework2023}.
% Hier altes oder neues diagram für den abstrahierten OAuth2 flow, falls noch platz ist
\begin{figure}
\includegraphics[width=\textwidth]{images/auth-code-grant}
\caption{Steps of the authorization code grant in the interaction between all roles as described in \cite{hardtOAuthAuthorizationFramework2023}}
\label{fig:auth-code-grant}
\end{figure}

\subsection{The Access Token}
\label{sec:accesstoken}

The OAuth2 specification does not define the nature of the access token. Although it can be any arbitrary string that has no further encoded information (this would be a reference token), it is considered best practice to use self-contained tokens like JSON Web Tokens (JWT), because the resource server itself can validate them and determine if the authorization is sufficient for the request, without having to build up a connection to the authorization server each time or maintaining a token database \cite{hardtOAuthAuthorizationFramework2023}. Specifically, in the context of distributed systems like MSA, the use of JWT as access tokens is advisable. One reason is that they can be validated locally and not every single request to the system has to be validated first with the authorization server, which could result in performance loss \cite{yang_research_2020}. The drawback of local token validation is that if a token has been revoked, the validating service doesn't know this and will give the client with the token access until it expires \cite{jacksonMicroserviceAuthenticationAuthorization2019}.  The use of JWTs as access tokens for OAuth2 is specified in RFC 9086 \cite{bertocciJSONWebToken2021}.

%. They also have the advantage that they usually expire after a while. The drawback of local token validation is that if a token has been revoked, the validating service doesn't know this and will give the client with the token access until it expires [!!! notfalls Nic Jackson].

The client requests access tokens from the \texttt{token endpoint} at the authorization server with a POST request including at least the \texttt{client\_id} and the \texttt{grant\_type} \cite{hardtOAuthAuthorizationFramework2023}. Confidential clients, wich are capable of maintaining secret information will also include a form of authentication, symmetric (password) or asymmetric (a signed JWT or mTLS). It is also possible for the client to include a \texttt{scope} request parameter. This is necessary for example when using OIDC (see section \ref{sub:oidc}).%hier nocheinmal quelle?

The response from the authorization server, if the authorization request was valid, includes several parameters \cite{hardtOAuthAuthorizationFramework2023}: the freshly issued access token  for the client and \texttt{token\_type}, which is usually \texttt{"Bearer"}, as well as a \texttt{scope} parameter are required by the specification. The authorization server can decide if the scope specified in the request will be included. Further recommended is \texttt{expires\_in}. A refresh token can also be included in the response, depending on the type of client and other factors. Figure \ref{fig:token-response-oauth} shows a token response from Keycloak. The lifespan for the access token is configured to be three minutes and because the authenticated user has only read privilege, the scope \texttt{tea\_read} is included.

\begin{figure}
\includegraphics[width=\textwidth]{images/token-response-oauth}
\caption{Token response from the Keycloak server in Postman}
\label{fig:token-response-oauth}
\end{figure}

A JWT is base64-encoded and is made of three parts, the header, payload and the signature. Any JWT that is used as access token for OAuth2 must be signed, as specified in RFC 9068, to ensure it's integrity, preferably with asymmetric cryptography \cite{bertocciJSONWebToken2021}. The header contains the \texttt{alg} parameter indicating the signing algorithm, which has to include \texttt{RS256}, and the \texttt{typ} parameter, which has to be \texttt{at+jwt} (recommended) or \texttt{application/at+jwt}. The payload contains the claims set where the following claims are mandatory for Oauth2 access tokens \cite{bertocciJSONWebToken2021}:

\begin{itemize}
\item \texttt{iss}: Issuer. Indicates the issuer of the access token.
\item \texttt{exp}: Expiration time. The life span of the access token before it becomes unvalid.
\item \texttt{aud}: Audience. Indicates the resource for which the access token should be used.
\item \texttt{sub}: Subject. The subject of the access token is an id that belongs to the resource owner, if involved, otherwise the client.
\item \texttt{client\_id}: Client ID. Identifier for the client requesting the access token.
\item \texttt{iat}: Issued at. The time when the access token was issued.
\item \texttt{jti}: JWT ID. Unique identifier for the JWT.
\end{itemize}

An example for a decoded access token is shown in figure \ref{fig:keycloak-access-token-aud-roles}, although it does not conform entirely to the specifications, as the  \texttt{typ} header parameter contains \texttt{JWT} instead of the required \texttt{at+jwt} value. The client id is instead present with the \texttt{azp} claim.

When validating the access token, the resource server checks the signature, lifespan, scope and possibly other authorization parameters for the specific resource \cite{hardtOAuthAuthorizationFramework2023}.
%gibts keine specification drüber, wie der rs an den key bzw jwks kommt?

%höher rauf schieben? 
%Different types of token !!!
%Aaron Parecki macht key card im hotel vergleich in OAuth: When things go wrong / oder everything you want to know
%By some aspects, the access token can be seen as a key to a door \cite{parecki_everything_2021}. It does not contain any information about the person using it, but as long as the key fits, the door will open. But unlike a key, one important security feature with OAuth2 access tokens is that they can expire. To spare the user the effort of having to grant permission again each time the token expires, the client application gets a refresh token along with the access token and once the access token has reached its defined expiration time, the client can then call the authorization server and exchange the refresh token for a new access token. A short expiration time makes it possible to validate access tokens locally, thus reducing the number of necessary calls. In case a permission to a client (represented by the access token) gets revoked at the authorization server, the service will not know this and the access token appears valid with local validation, but only until it expires. Therefore, it is important to evaluate carefully where in the MSA local validation is sufficient and where validation with the authorization server is necessary for higher security \cite{parecki_everything_2021}. In any case, it is highly recommended to never accept unvalidated access tokens \cite{jackson_microservice_2019}.\\
%Hier evt. Zeichnung

%Alle Infos in dem Absatz kommen eigentlich von Siriwardena 2020 (Adv.) -> wo die Referenz hinschreiben?
%The nature of the access token is not defined in the OAuth2 specification. It can be an arbitrary string that serves as a reference to the authorization information, or a self-contained token \cite{jones_oauth_2012}. A reference token is susceptible to brute force attacks, therefore additional strategies to prevent brute forcing must be implemented \cite[121]{siriwardena_advanced_2020}. In order to validate a reference token, a call to the issuing authorization server is inevitable. On the other hand, a self-contained token can be validated locally by means of the signature it carries \cite[p.~121]{siriwardena_advanced_2020}. A very popular format for access tokens is the JSON Web Token (JWT) format, which will be discussed in more detail in section \ref{sec:jwt}. In any case, the access token is defined as a string that represents the authorization for the client, but also the scope and duration of access \cite{hardt_oauth_2012}. It has no meaning to the client, similar to how a person does not need to know how a lock and key work in order to open a door.

%The definition for access token privilege restriction in RFC 9068 \cite{bertocci_json_oauth_2021} states that access tokens should be restricted to a specific resource server (several resource servers are possible, but preferably only one). This prevents clients as well as users from exceeding their privileges. Resource servers at the other end must check if they are the intended resource server for that access token \cite{lodderstedt_oauth_2022}. The scope is defined by the authorization server. It is not mandatory for a client to ask for a specific scope, but if it does not do that, the authorization server must either fail the request altogether, or issue an access token containing a default scope \cite{hardt_oauth_2012}.

%Next to the access token, there is also a \textit{refresh token} \cite{hardt_oauth_2012}. It can be issued to the client together with the access token (with certain grant types) and permits the client to request a new access token when the previous one has expired \cite{hardt_oauth_2012}. With the refresh token it is possible to define short expiration times for access tokens. The new token will not be issued when the permission has been revoked, but as long as this is not the case, the new token can be minted without bothering the resource owner.%!!! quelle nötig? 

%bearer token oder sender-constrained!!!\\

%quasi das gleiche nocheinmal\\
%The specification for OAuth 2.0 [!!! RFC6749] states explicitly that "access tokens can have different formats, structures, and methods of utilization". However, it is very common to use JWT in the OAuth2 flow [!!!RFC9068]. Specifically, in the context of distributed systems like MSA, the use of JWT as access tokens is advisable. One reason is that they can be validated locally and not every single request to the system has to be validated first with the authorization server, which could result in performance loss \cite{yang_research_2020}. They also have the advantage that they usually expire after a while. The drawback of local token validation is that if a token has been revoked, the validating service doesn't know this and will give the client with the token access until it expires [!!! notfalls Nic Jackson]. More details about JWT will be given in section \ref{sec:jwt}. !!!evt. ist das nicht mehr up to date? es gibt sehr frische spec drafts zu oauth.\\


%Security Threats related to Bearer Tokens (!!!RFC 6750) zusammenfassen oder ist das übertrieben?\\
%Trotzdem recommenadations hier? achtung, es gibt ein eigenes rfc mit oauth threat model\\



%oauth.net: access tokens do not convey user information

% was evt noch fehlt: wie ist das mit dem third-party access im kontext von microservices zu verstehen? Wird da irgendwo drauf eingegangen? Siriwardena und Dias: protected resource - client can access, if user authenticates;  client kann first-party acces zu eigenem resource server machen (siehe kommentar oben)



%It is important to note that OAuth2 does not deal with the issue of authentication. Another protocol, OpenID Connect (OIDC), was developed to handle authentication and is build on top of OAuth2. 
%Before OIDC was developed, it was common to use OAuth2 for authentication as well and it still occurred later on, but it is strongly discouraged to do so . More details about OIDC are given in section \ref{sec:oidc}.\\

%bsp hier einfügen, oauth.net artikel zitieren...

%\subsection{JSON Web Token (JWT)}
%\label{sub:jwt}
%The JSON Web Token format (JWT) is a compact format for transmitting information (also known as claims) between two parties over HTTP and it is defined by the IETF in RFC 7519 \cite{jones_json_2015}. It has become a popular choice for the use as access token in OAuth2, as described in the JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens specification, RFC 9068 \cite{bertocci_json_oauth_2021}, because it is self-contained and gives the possibility to be validated locally by the resource server (within the limitations discussed in section \ref{sec:oauth}). While it is possible to implement an authorization mechanism using JWTs without the OAuth2 protocol, this topic lies outside the scope of this thesis. The following section will focus on the nature of JWT in general and on its use as OAuth2 access token.

%A JWT is a JSON object, encoded in a JSON Web Signature (JWS) or JSON Web Encryption (JWE) structure, or both \cite{jones_json_2015}. This means, it offers the possibility to be cryptographically signed and/or encrypted. Although it is possible to transmit unsigned JWTs, signing JWT access tokens is now mandatory for OAuth2 \cite{bertocci_json_oauth_2021}. Signature algorithms can be either symmetric or asymmetric, but for OAuth2 access tokens, it is recommended to use asymmetric cryptography, and RS256 must be supported by authorization servers as defined in RFC 9068 \cite{bertocci_json_oauth_2021}, but experts have recommended this for some time already, e.g. \cite{jackson_microservice_2019}.

%??? wirklich mind. 2? was ist typisch für OAuth2?
%A signed JWT consists of three elements, each of them base64-encoded and separated with a ".". The first element is the JavaScript Object Signing and Encryption (JOSE) header, the second is the JWT payload and the third is the signature \cite{jones_json_2015}. Typically, the JOSE header contains the \texttt{typ}  parameter (defined in the JWT specification \cite{jones_json_2015}, which should have \texttt{JWT} as a value, and, more specifically for OAuth2 access tokens, it must be \texttt{at+jwt} \cite{bertocci_json_oauth_2021}. Special attention will be paid also later in this thesis to the \texttt{alg} parameter, which is not defined in the JWT specification, but in the specification for JWS in RFC 7515 \cite{jones_json_2015-2}. The \texttt{alg} parameter indicates the algorithm used to cryptographically sign the JWT and the respective value must be either registered in the IANA "JSON Web Signature and Encryption Algorithms" registry, or contain a collision-resistant name. As per the RFC 9068, it must never contain "none" as a value. Finally, the \texttt{kid} (key ID) parameter contains a hint about the key that was used to sign the JWS \cite{jones_json_2015-2}. It is optional and can be used to indicate a key change.

%The second element of the JWT is the JWT claims set \cite{jones_json_2015}, or JWT payload \cite[p.~160]{siriwardena_advanced_2020}. It contains the "business data" \cite[p.~160]{siriwardena_advanced_2020} of the JWT. The JWT specification does not define which claims are mandatory, but rather leaves this to the specific applications to define. However, it is defined that only claims that are understood by the recipient can be accepted. The JWT specification also defines a list of "registered Claim Names", which are not intended to be mandatory, but are intended as a starting point for further specification. Out of these, the following claims, all defined in RFC 7519 \cite{jones_json_2015}, are required for the use in JWT access tokens \cite{bertocci_json_oauth_2021}:
%\begin{itemize}
%\item \texttt{iss}: The issuer of the JWT.
%\item \texttt{exp}: The expiration time, after which a token must not be processed any more.
%\item \texttt{aud}: This parameter identifies the resource for which the access token is intended. It is mandatory as per RFC 9068 in order to prevent cross-JWT confusion, so access tokens issued by the same authorization server for different resources remain unique \cite{bertocci_json_oauth_2021}.
%%\item \texttt{sub}: The subject of the JWT, either the resource owner (authorization code grant) or the client (client credentials grant), depending on whether a resource owner is involved in granting access \cite{bertocci_json_oauth_2021}.
%\item \texttt{iat}: Issuing time of the token. %wörtlich, nur gekürzt von bertocci
%\item \texttt{jti}: JWT ID, a unique identifier for the JWT.
%\end{itemize}

%The kind of access that is requested can be specified within the \texttt{scope} parameter in the request from the client to the authorization server, but often it also contains identifiers for the resource itself or its location \cite{campbell_resource_2020}. To lessen the burden on the \texttt{scope} parameter, there is also a more recent RFC that defines \texttt{resource} \cite{campbell_resource_2020} for the this purpose. However, in the access token, the resource server is indicated not by the \texttt{scope} parameter, but by the \texttt{aud} parameter \cite{bertocci_json_oauth_2021}. Additionally, the \texttt{client\_id} claim, as defined in the RFC 8693 \cite{jones_oauth_2020}, as the name suggests, identifies the OAuth2 client that requested the access token. When using OIDC, other optional claims may become relevant, such as \texttt{auth\_time}, \texttt{acr} and  \texttt{amr}, which are defined in the OpenID Connect Core specification \cite{sakimura_openid_2014}. When first-party clients invoke a backend API belonging to the same solution, it is common that resource owner attributes are carried in the access token.

%The access token is issued in response to a request by the client, as in Listing \ref{lst:jwtreq}. The token corresponding to the example request in listing \ref{lst:jwtreq} can be seen in listing \ref{lst:jwtaccess}.

%\begin{lstlisting}[frame=lines, caption=Example request for an access token according to \cite{bertocci_json_oauth_2021}, captionpos=b, label = lst:jwtreq, language=C, showstringspaces=false]

%   GET /as/authorization.oauth2?response_type=code
%           &client_id=2349832dg8s7f87
%           &state=123456789
%           &scope=%read%write%delete
%           &redirect_uri=https%3A%2F%2Fclient%2Eulala%2Enet%2Fcb
%           &resource=https%3A%2F%2Frs.ulala.com%2F HTTP/1.1
%        Host: authorization-server.ularauch.net
%\end{lstlisting}

% nicht-oidc beispiel wäre hier besser, weil oidc noch nicht erklärt wurde. sonst auf oidc-kapitel verweisen.
%\begin{lstlisting}[frame=lines, caption=Example JWT access token according to \cite{bertocci_json_oauth_2021}, captionpos=b, label = lst:jwtaccess, language=C, showstringspaces=false]
%Header:

%      {"typ":"at+JWT","alg":"RS256","kid":"RjEwOwOA"}

%   Claims:

%{
%    "iss": "https://authorization-server.ularauch.net/",
%    "iat": "2022-12-31T19:02:23.942Z",
%    "exp": "2022-12-31T19:12:23.942Z",
%    "aud": "https://rs.ulala.com/",
%    "sub": "5ba552d67",
%    "jti": "dbe39bf3a3ba4238a513f51d6e1691c4",
%    "client_id": "s6BhdRkqt3",
%    "scope": "read write delete"
%}
%\end{lstlisting}

%expiration time - should be short!!! \cite{yarygina_overcoming_2018}
%clock synchronization problem (!!! yarygina), secure token transmission over TLS, private key must kept safe.

%state parameter in oidc - und oauth wahrscheinlich auch... -> doch einen csrf-abschnitt machen? wo am besten?

\subsection{OpenID Connect (OIDC)}
\label{sub:oidc}

When it comes to authentication of end-users, OIDC \cite{sakimuraOpenIDConnectCore2014} gives the answers that were left out bei OAuth2. The content of an OAuth2 access token is of no interest for the client. When the client needs information about a user's identity, it can request an additional \textit{ID token} by adding \texttt{openid} to the \texttt{scope} parameter in the authorization request, which thus becomes a authentication request. Also the \texttt{redirect\_uri} parameter is now required. Among other optional parameters there is the \texttt{nonce} parameter to mention. It is a string value, used to protect against replay attacks, that should be unguessable and it represents session state between the client session and the ID token. The ID token will then be issued by the authorization server which is now called OIDC provider (OP), together with the access token and delivered as a part of the token response \cite{sakimuraOpenIDConnectCore2014}.
The ID token itself is a signed JWT which contains the \texttt{iss, sub, aud, exp} and \texttt{iat} claims as a requirement. When using the authorization code flow, also the \texttt{at\_hash} claim is required. It contians a the  base64 encoded left most half of the corresponding access token's hash. The \texttt{nonce} claim is reqired if it was present in the authentication request, with the same value, which will be verified by the client. Other optional claims are \texttt{amr} (authentication method references), \texttt{acr} (authentication context class reference) and \texttt{azp} (authorized party), containing the client id of the authorized client. The ID token itself does not contain personal user information. Instead there is a separate OAuth2 protected \texttt{/userinfo} endpoint where the client can request additional metadata about the user with the access token \cite{sakimuraOpenIDConnectCore2014}.

!!! Verweise auf Listings oder Screenshots, die später eingefügt werden als beispiel

%was brauchts von dem Teil noch?
%Today, when reading about OAuth2, the warning that OAuth2 should not be used for authentication is hard to overlook. Still, authentication is an important component in order to secure a system and OAuth2 can be used \textit{within} an authentication scheme \cite{richer_end_nodate}. With OAuth2, the resource owner will authenticate to the authorization server and also the client has to authenticate to the authorization server in many cases, but it is not the concern of OAuth2 \textit{how} the authentication is done \cite{richer_end_nodate}. In this context it is useful to understand that for the client the access token has no meaning and will just be passed on to the resource server for validation. The client does not learn anything about the user and the fact that an access token was issued should not be misunderstood as a proof that the end-user was correctly authenticated \cite{richer_end_nodate}. When information about the user is needed, OAuth2 is therefore not sufficient to cover authentication, even if this has not been and might still not be an unusual practice \cite{barbettini_oauth_2018}, \cite{jackson_microservice_2019}. The problems and pitfalls associated with the use of OAuth2 for authentication purposes are discussed more in detail in \cite{richer_end_nodate}. Instead, OpenID Connect (OIDC) is a layer on top of the OAuth2 specification and has been developed exactly for this purpose.

%more security aspects: tls - ist MUST in specs, csrf state parameter, nonce (auch in oauth?)



%OpenID Connect 1.0 (OIDC) is an open protocol defined as a layer on top of OAuth2 by the OpenID Foundation \cite{sakimura_openid_2014} in 2014. Often there is a need for clients to be able to identify end-users, and OAuth2 does not fulfil this purpose, because it is not intended to be used for authentication. OIDC was developed to close this gap \cite{richer_end_nodate}.

%An OIDC flow is very similar to the OAuth2 flow, with a small, but significant difference: in addition to the access token, the authorization server, which is also responsible for handling authentication of the end-user, thus now being an OIDC provider or authentication server, issues also an ID token \cite{sakimura_openid_2014}, \cite{richer_end_nodate}.
%The client can also send the access token to the UserInfo Endpoint (at the OIDC provider), which will return a defined set of additional standard claims about the user \cite{sakimura_openid_2014}.
%---Zeichnung für OIDC flow hier---\\
%The OIDC flow consists of the following steps \cite{sakimura_openid_2014}:
%\begin{enumerate}
%\item Authentication request from the client to the OIDC provider
%\item Authentication of the end-user at the OIDC provider + obtaining authorization
%\item ID token (and usually access token) issued by OIDC provider to client
%\item UserInfo request with access token from client to UserInfo endpoint
%\item UserInfo response from UserInfo endpoint to client
%\end{enumerate}

%The OIDC specification provides three specific authentication flows \cite{sakimura_openid_2014}:
%\begin{itemize}
%%\item The \textit{authorization code flow}, similar to the process described for the authorization code grant in section \ref{sec:oauthgrants}, but an ID token is issued to the client together with the access token.
%%\item The \textit{implicit flow}, again similar to the OAuth2 implicit grant. The OIDC provider redirects the end-user to the client, together with the ID token and the access token.
%%\item The \textit{hybrid flow} combines characteristics from both other flows. Clients receive always an authorization code and additionally the access token or the ID token. The other token can be exchanged for the authorization code.
%\end{itemize}

%As per the OAuth2 specification, an access token is opaque to the client \cite{hardt_oauth_2012}. In order to maintain this requirement, the ID token carrying information for user authentication is a separate token, issued alongside the access token \cite{sakimura_openid_2014}. The ID token is a JWT, containing claims similar to the OAuth2 access token, such as \texttt{iss, aud, exp, iat} (see section \ref{sec:oauth}, but also the \texttt{sub} claim, to uniquely identify the subject (end-user) with the client, \texttt{nonce}, which is used to prevent replay attacks and to associate the ID token with a client session, and other optional claims (\texttt{acr, amr, azp}). Other claims are possible as well, however, claims must be understood or be ignored otherwise. An example for an ID token is given in listing \ref{lst:idtoken}, where also the \texttt{auth\_time} claim is used, denoting the time when the user has authenticated. An OIDC authentication request is an OAuth2 authorization request where the \texttt{scope} parameter must be present with \texttt{open\_id} as a value. Other values for \texttt{open\_id} can be present as well \cite{sakimura_openid_2014}.\\

%section 3.1.2.1.
%\begin{lstlisting}[frame=lines, caption=Example for an ID token according to \cite{sakimura_openid_2014}, captionpos=b, label = lst:idtoken, language=c, showstringspaces=false]
% {
%   "iss": "https://server.ularauch.net",
%   "sub": "24400320",
%   "aud": "s6BhdRkqt3",
%   "nonce": "n-0S6_WzA2Mj",
%   "exp": 1311281970,
%   "iat": 1311280970,
%   "auth_time": 1311280969,
%   "acr": "urn:mace:incommon:iap:silver"
%  }
%\end{lstlisting}

%section 5.3.2
%\begin{lstlisting}[frame=lines, caption=UserInfo Response example according to \cite{sakimura_openid_2014}, captionpos=b, label = lst:userinfo, language=c, showstringspaces=false]
%  HTTP/1.1 200 OK
%  Content-Type: application/json

%  {
%   "sub": "248289761001",
%   "name": "Ula Rauch",
%   "given_name": "Ursula",
%   "family_name": "Rauch",
%   "preferred_username": "ulala",
%   "email": "ursula.rauch@stud.fh-campuswien.ac.at",
%   "picture": "http://ularauch.net/ulala/ula.jpg"
%  }
%\end{lstlisting}


%Although the ID token appears to be very similar to an access token, there are some important differences to be pointed out \cite{parecki_oauth_nodate}:%https://oauth.net/id-tokens-vs-access-tokens/ - genaue seite angeben?
%\begin{itemize}
%\item The audience: ID tokens should only be sent to and read by the OAuth2 client. Consequently, ID tokens should never be sent to an API. Access tokens should be read only by the API (the resource server) it was meant for, but never by the client.
%\item The format: the format for access tokens is not specified, it can be a JWT, but it can also be an arbitrary string, while on the other hand an ID token is always a JWT.
%\end{itemize}

%OIDC also defines a protected resource at the OIDC provider, the UserInfo endpoint, where the client can request a set of standard claims with meta-data about the user in question in exchange for the access token \cite{sakimura_openid_2014}. An example for these claims is shown in listing \ref{lst:userinfo}. Also, like in the initial authentication request, the \texttt{scope} parameter must be present with the value \texttt{open\_id} in the request for userInfo claims \cite{sakimura_openid_2014}.

%Ende: betonen, dass das nicht obligatorisch ist? steht bei richer, aber kommt aus der oidc spec nicht so raus.

% Noch mehr OIDC:

%Why - pitfalls with using OAuth2: evt. auslassen, nur das wichtigste funktionale

%Important to not confuse it with OpenID, which is not just a short name of OpenID Connect, but rather the other way round, OpenID is independent of OAuth 2, while OpenID Connect is its extension 

%trennung zwischen access token und id token essentiell -> inhalt vom access token geht den client wenig an, dafür kann mit infos aus id token eine session gemacht werden \cite{ideskog_oauth_nodate} (bis eine bessere quelle kommt, spec lesen!)


\section{The positioning of the OAuth2 client in a MSA system - CHECKEN}
\label{sec:msa-oauth}
!!! nocheinmal anschaun. wo soll der abschnitt hin und was ist die intention? Titel?
%API gateway wurde evt. schon in MSA einführung erklärt
When bringing the two concepts of MSA and Oauth2 together, some decisions have to be made about the role of each service, which also depend on the overall architecture of the microservice system. Many different architectural patterns for MSA have been proposed and studied \cite{akbulutPerformanceAnalysisMicroservice2019}. One very common pattern is the API Gateway, which functions as entry point for requests coming from a browser, a mobile application or any other kind of frontend \cite{bazeniucInformationSecurityMicroservices2021}, so that the single backend services are not required anymore to be reachable from the outside. A very similar pattern is Backends for Frontends (BFF), where as many different gateway services are implemented as there are different frontend applications \cite{SamNewmanBackends}. The distinction between the two patterns seems to be fluent to a certain degree. Sometimes it is called a BFF when an API Gateway assumes the functionalities of an OAuth2 client \cite{SpringaddonsSamplesTutorials}, \cite{SamNewmanBackends}, however this does not seem to meet the full definition of a BFF.

The most simple implementation would probably be to implement only the gateway as OAuth2 resource server, but not the backend services, assuming that the gateway will deal with any unauthorized request. For this scenario there are other ways to secure the communication between services, like mutual Transport Layer Security (mTLS), supposedly the most popular option (see \cite[pp. ~137ff]{siriwardenaMicroservicesSecurityAction2020}. This means that the service holding a requested resource might not necessarily be a resource server in the sense of OAuth2. The Gateway will decide if the user should access a resource and it will forward the request only if the user can prove to have the necessary authorization (access token). However this comes with drawbacks, for example it does not meet the requirement of defense in depth, where access control happens on several layers and access control in one single point can become hard to manage with a more complex access policy and many roles involved \cite{barabanovAuthenticationAuthorizationMicroservicebased2020a}. For better security it is also possible to implement several resource servers in a series, which either renew the access token or hand down the original access token to the next downstream service after validation \cite[pp.~161ff]{siriwardenaMicroservicesSecurityAction2020}. This is similar to the chain of responsibility pattern \cite{akbulutPerformanceAnalysisMicroservice2019}. A simplified version of this concept has been implemented and tested for this thesis (see chapter \ref{chap:implementation}). In both cases however, the job position of a (registered) OIDC client is still vacant. There should be a service or application that is able to determine if the user has already authenticated, refer to the OP for authentication and obtain the access token on the user's behalf. This means that any possible frontend has to implement OIDC client functionality.

Another version, which can sometimes be found in OAuth2/OIDC MSA tutorials, relieves the frontend of this burden and implements the gateway directly with the functionality of an OAuth2 client. This variant was also implemented for this thesis and is described in detail in section \ref{chap:implementation}. The services beyond are resource servers, so that the communication between the API gateway and the next downstream service is secured via access tokens, while the gateway keeps a session for the communication with the frontend to know if the requesting user is authenticated.

Naturally, both variants, with the API gateway or the frontend application as the OAuth2 client bring advantages and disadvantages in different aspects, like system performance, code complextiy and further security considerations. In chapter \ref{chap:implementation}, not only the implementation of a prototype is described, but also the setup for a performance test in order to compare response times of both variants. The results of these tests are presented and discussed in section \ref{chap:results} (!!! discussion separat oder getrennt?).
(!!! code complexity und security?)

\section{Methodology - VERVOLLSTÄNDIGEN}
\label{sec:methodology}
!!! Darf ich das so schreiben?
The first research question, how OAuth2 authorization and authentication with OIDC are implemented in MSA using Spring Boot and the Spring Security Framework with a Keycloak server, was answered mainly by collecting and combining information from online tutorials and use them to implement a prototype as a proof of concept. The implementation is described in detail in chapter \ref{chap:implementation}. It should be noted that the aim was not to follow or develop a best practice model. For example in production TLS would be required on all connections, but was left out because the focus lies on authentication and authorization of users with OAuth2 and OIDC. Also mTLS was considered to be beyond the scope of this thesis and therefore left out. Correct authentication and authorization of end users was tested and examined using Postman\footnote{https://www.postman.com/} and Wireshark\footnote{https://www.wireshark.org/}.

In the first version, the API gateway was implemented as OAuth2 client. In order to investigate the matter of the positioning of the OAuth2 client, the system was recreated in three versions, containing only the necessary features for a performance comparison between the API gateway as client, as resource server and a completely unsecured version to relate the outcome. Performance tests were carried out using Apache JMeter\footnote{https://jmeter.apache.org/}. Details about the setup are documented in section \ref{sec:loadtesting-jmeter}.
(!!! code complexity und security?)

%Für Forschungsfrage 1: Follow Spring Boot Documentation and Tutorials -> implement the Teapot and test Authentication and Authorization functionality with Browser, Postman and Wireshark.
%Für Forschungsfrage 2: Implement a reduced version of the Teapot system in three different ways and perform load tests with jmeter. Compare response times.

\chapter{Implementation}
\label{chap:implementation}

Einleitende worte?

The Teapot Services were developed with IntelliJ IDEA 2023.1.2 (Ultimate Edition). All Services including the Keycloak server were then deployed with Docker version 23.0.5 and Docker Compose version 2.17.3.
!!! Spring, JMEter und Keycloak versionen auch hier?
%!!! Was noch?


%!!! hier nur abgelegt:
%	With the basic implementation of the prototype system (see section 4 Impl (reihenfolge tauschen?), 4 different versions were created: one with the Gateway as the OAuth2 client and with the Tea Service as a Resource Server, one where the Gateway and the Tea Service are both Resource Servers and one where only the Gateway is a Resource Server and the Tea Service remains unprotected. The initial intention was to implement MTLS between the Gateway and the Resource Server as recommended in [Siriwardena - Microservices Security in Action - Seite???]. This last version was later abandoned in favour of the focus on the difference of the client position in the system. Testing a difference between OAuth2 and MTLS lies outside the scope of this thesis.

\section{The Teapot - High level design -ÜBERARBEITEN!}
\label{sec:high-level}
!!!
In order to become familiar with MSA, OAuth2 and OIDC, the first project that was built is a virtual tea kitchen, called "The Teapot". It then served as a starting point for the comparison of different Oauth2 client positions, with some simplifications and changes to serve the purpose.

In the original Teapot system the user can view a list of available types of tea and make a cup with the chosen tea. The backend is a MSA and consists of the API Gateway, the Tea Service with a MongoDB database, which offers endpoints for creating or updating a type of tea, requesting the list of all available types, deleting tea and "making tea", where the user gets back a message containing the requested type of tea or just hot water, if the requested tea is not available. There is also a separate Milk Service and a Eureka Discovery Service where the Gateway and the other Services are registered. The gateway offers endpoints to the outside world and stands between the other services and the users. It routes requests requests to the Tea and Milk Service respectively, so that the user or any frontend doesn't have to communicate directly to the services beyond the gateway. A keycloak server is deployed for security, serving as both, identity server for user authentication and authorization server for the services. The high-level architecture of the teapot is depicted in figure \ref{fig:original-teapot-architecture}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/original-teapot-high-level}
	\caption{High level diagram of the implemented services and their relation to each other}
	\label{fig:original-teapot-architecture}
\end{figure}


However, since there is a lot of functionality present that is not necessary for this research, the whole system was rebuilt in a even simpler version: All that we need is the gateway and one additional service for the gateway to communicate with, and of course the keycloak server. So the Milk Service as well as the Discovery Service disappeared completely. The database still exists in the new system, but since it became clear that it would only add unnecessary overhead to the requests it is not in use anymore. Neither is the whole create/read/update/delete (CRUD) functionality. Instead, the Gateway and the Tea Service offer "hello"-endpoints that were used in the beginning for debugging. In the end, these endpoints were used for load testing, as will be described in more detail in section ???. They return a simple string message and do not require the database. This means that the gateway has two relevant endpoints: \texttt{/helloauth}, which the gateway itself responds to immediately, and  \texttt{/hellotea/name}, which is routed from the gateway to the Tea Service. \texttt{name} can be any string and will be returned in the responding message.
The remaining, stripped-down system is represented by figure \ref{fig:teapot-architecture}.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/teapot-high-level}
	\caption{High level diagram of the implemented services and their relation to each other}
	\label{fig:teapot-architecture}
\end{figure}

In total, there are three versions of this system: the first version where the Gateway acts as the OAuth2 client and the Tea Service serves as the resource server, the second version where both the Gateway and the Tea Service function as resource servers, and a third version with no security implementation at all. The second version would require the inclusion of a frontend application to incorporate OAuth2 client functionality.

With this implementation, the first request to a protected resource, when the gateway hasn't obtained an access token yet, can be depicted as in figure \ref{fig:oauth2-flow-seqd}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/oauth2-flow_sequence-diagram}
	\caption{Sequence diagram of the first request to a protected resource including a simplified auth code grant flow}
	\label{fig:oauth2-flow-seqd}
\end{figure}

The detailed auth code grant flow has already been shown and explained in section ???, therefore a simplified version is depicted in this diagram.

Any subsequent request, as long as the access token is valid, is much simpler. The gateway already has an access token and all it has to do is append this access token to the routed request as authorization header and forward it to the Tea Service. This scenario is also used for load testing, as will be explained in section ???.

The second version does not implement a client at all. It is simply two resource servers in series. The gateway recieves an access token with the request from the user, in theory via some frontend client, in the case it is sent by a jmeter script  validates and forwards it to the Tea Service, which again validates the access token 
In both versions, the Tea Service, or the Tea Service and the Gateway respectively must obtain the JSON Web Key Set (JWKS) from the Keycloak Server, so that they will be able to validate the access token. This happens at the first request.
% detaillierte abbildungen sind hier evt. redundant... später weitermachen!

The third version is again a copy of the other two but the Keycloak Server is not needed in this case and the services do not care about authorization at all.

\section{Setup with Spring Boot and Keycloak}
\label{sec:setup-spring-boot}

\subsection{Spring and Spring Boot}
!!! versionen
All Services in this project were developed using Spring Boot\footnote{https://spring.io/projects/spring-boot} Version 3.0. 
Spring Boot is created on top of the Spring framework, a widely used open source application framework for Java. Spring provides dependency injection and different modules, like Spring Security, Spring Test or Spring ORM (object-relational mapping), among others \cite{IntroductionSpringFramework}. Spring Boot was created in order to simplify the development of Spring-based applications by offering autoconfiguration and starter dependencies that bundle selections of libraries in one Maven or Gradle dependency \cite[pp.~4f]{wallsSpringBootAction2016}. This helps to reduce the need for the developer to write boilerplate code manually, which means that one big advantage when using Spring boot is the quick project setup. However, these configurations can be overridden or customized when needed, like it is the case for security configurations \cite[p.~50]{wallsSpringBootAction2016}, either programmatilally with Java or in many cases by adding configurations to the \texttt{applications.properties} or the \texttt{applications.yml} file \cite{CoreFeatures}. For the Teapot project the \texttt{yml} variant was used whenever possible because this way configurations are easier to write and read, and therefore they are less error-prone.

Spring Boot projects can be initialized and downloaded with the Spring Initializr\footnote{https://start.spring.io/} which is also available when creating a new Project in IntelliJ. All Maven dependencies that are needed for a project can be chosen during project creation with Spring Initializr, or they can be added later to the \texttt{pom.xml} file.

\subsection{Keycloak Server}
\label{sub:keycloak}

Keycloak \cite{Keycloak} is an identity and access management (IAM) platform. It is open source and published under the Apache Licence 2.0\footnote{http://www.apache.org/licenses/LICENSE-2.0}. It supports OAuth2, OIDC and SAML. As an IAM, the Keycloak server can take care of user management, authentication of users and issuing access tokens and id tokens to registrated clients. The version used for the Teapot project was 20.0 (Quarkus distribution). The Keycloak server was deployed locally in a docker container in dev mode. Keycloak supports different databases to store data, however, the default database (dev-file) was sufficient for the Teapot project. The Keycloak server already contains a \texttt{master realm} with the administrator account. The \texttt{master realm} is the parent of all other realms that can be created by an administrator. For this project, a \texttt{teapot realm} was created. Inside a realm, administrators can create (register)and manage clients and users. The Teapot Gateway needs to be registered as a client in the Teapot realm. When it is created, the client secret is set automatically for the new client, if \texttt{Client authentication} is enabled. This is possible because the Teapot Gateway is a confidential client. The secret is used by the Gateway application when connecting to the Keycloak server to authenticate itself. %With a public client, like a single page application (SPA) or a mobile application, no password should be involved (!!! Quelle aus BA1 raussuchen).%passt eigentlich nicht an diese stelle...

%nicht ganz easy reproduzierbar, evt. hat da nur die falsche adresse mitgespielt, die docker ins hostfile geschrieben hat und es wär sonst nicht so kompliziert gewesen?
For the Teapot project setup where all services are deployed with Docker Compose, the \texttt{Frontend-Url} is set to \texttt{http://host.docker.internal:10001} where the host name is the docker network and the port is the port assigned to Keycloak. If the \texttt{Frontend-Url} is not set explicitly, the host name for the Keycloak endpoints that are used for authentication and authorization flows is set to \texttt{localhost}. Services in other Docker containers access the Keycloak server under it's \texttt{host.docker.internal} url. The frontend-url also determines how the \texttt{iss} claim is set in access tokens, which must be identical with the \texttt{issuer-uri} set at the resource server(!!! Quelle). If \texttt{iss} claim and \texttt{issuer-uri} do not match, the access token does not pass the validation and a \texttt{401} response will be sent back with a remark in the \texttt{XXX-Authenticate} header that the \texttt{iss} claim is not valid (see figure \ref{fig:iss-not-valid-header}).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/iss-not-valid-header}
	\caption{Response header indicating that the \texttt{iss} claim is not valid.}
	\label{fig:iss-not-valid-header}
\end{figure}

All endpoints of the Keycloak server for a realm are accessible under \texttt{<host:port>/realms/<realmname>/.well-known/openid-configuration}. OAuth2 resource servers and clients with the correct \texttt{issuer-uri} can call this endpoint to retrieve the other necessary endpoints, like \texttt{authorization\_endpoint}, \texttt{token\_endpoint}, \texttt{jwks\_uri}, etc., but also other necessary information like supported signing algorithms, grant types, etc. Figure \ref{fig:keycloak-well-known-endpoints} shows the first part of these endpoints.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/keycloak-well-known-endpoints}
	\caption{Keycloak endpoint configuration for the teapot realm (not complete).}
	\label{fig:keycloak-well-known-endpoints}
\end{figure}

% keycloak supports discovery...


% admin console
% realms
% clients
% users
% wie hab ich ihn configuriert?
% Docker compose -> config importiert

\subsection{Spring Cloud Gateway as OIDC Client}
\label{sub:gateway-cl}
%Umbenennen in The Gateway?
The Gateway's job in a MSA is to route requests to services beyond. There is a special Spring Boot starter dependency, \linebreak\texttt{spring-cloud-starter-gateway}, that was used for the implementation of the Teapot project. Maven dependencies are injected in the \linebreak\texttt{pom.xml} file in the following way:

\begin{verbatim}
        	<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
\end{verbatim}

With the Spring Cloud Gateway implemented, a Handler Mapping checks incoming requests for matches with configured routes and if so, forwards them to the Gateway Web Handler. The request then goes through a filterchain where route-specific pre- and post-logic is applied\cite{SpringCloudGatewaya}.

Routes can be configured in the \texttt{application.properties} file or in the \linebreak\texttt{application.yml}. Figure \ref{fig:gateway-route-config} shows an example route configuration from the \texttt{application.yml} file in the reduced Teapot project where no discovery service is used. The \texttt{uri} value is given as an environment variable and will be injected via the docker compose.yml file (!!! see docker). With the Eureka discovery service in the first Teapot, the value would be \texttt{lb://} followed by the name that the Tea service application uses to register with the discovery service. This way the Gateway does not have any need to know the specific current address of the Tea Service or any other application it is routing a request to. The \texttt{Path} predicate defines the path for the endpoint at the gateway. So in this case, requests to \texttt{http://localhost:8181/hellotea/Ula} will be recognized as a match for \texttt{\${TEAS}/teas/hello/Ula}, the path that is set under \texttt{filters} with the \texttt{SetPath}. \texttt{Ula} is an example value for the \texttt{{name}} variable.

\begin{figure}[htbp]
	\centering
		\includegraphics{images/gateway-route-config}
	\caption{Example route configuration from the Gateway's application.yml file in the reduced Teapot project}
	\label{fig:gateway-route-config}
\end{figure}

In order to configure the Gateway as OAuth2 client, we also need to include the \linebreak\texttt{spring-boot-starter-oauth2-client} dependency in the \texttt{pom.xml} file:
\begin{verbatim}
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-client</artifactId>
        </dependency>
\end{verbatim}

Here it is important to choose the correct starter dependency and to not get confused by the different oauth2-client dependencies available, as there are many with similar names. The \linebreak\texttt{spring-boot-starter-oauth2-client} dependency is intended to be used with Spring Boot \cite{GettingStartedSpring}. Then, after having created the client in Keycloak (see section \ref{sub:keycloak}), the application needs to be configured so it can connect to the authorization server and register with the client's credentials. All this is done in the \texttt{application.yml} file (see listing \ref{lst:clientconfig}.
\begin{lstlisting}[frame=lines, caption=OAuth2 client configuration in the Gateway's application.yml file, captionpos=b, label=lst:clientconfig, language=Java, showstringspaces=false]
spring:
[...]
  security:
    oauth2:
      client:
        provider:
          keycloak-provider:
            issuer-uri: ${keycloak.server-url}/realms/teapot
        registration:
          keycloak-gateway-client:
            provider: keycloak-provider
            scope: openid
            client-id: teapot-gateway
            client-secret: ${client-secret}
            authorization-grant-type: authorization_code
            redirect-uri: 'http://localhost:8080/login/oauth2/code/{registrationId}'
\end{lstlisting}

For this purpose we use the \linebreak\texttt{spring.security.oauth2.client.registration} base property prefix, followed by the registration id that will be used by Spring Security's \texttt{OAuth2ClientProperties} class. In this project the client's registration id is \texttt{keycloak-gateway-client}. As explained in section \ref{subsec:oidc}, \texttt{oidc} must be included in the scope claim. Further, the \texttt{client-id} and the \texttt{client-secret}, as well as the \texttt{authorization-grant-type} and the \texttt{redirect-uri} are specified. The \texttt{redirect-uri} is the address that the authorization server will send to the user agent to redirect the user back to the application after authorization has been granted (see section \ref{sec:oauth2}).
The provider section contains the provider name, in this case \texttt{keycloak-provider}. This is the name which the \texttt{registration} section refers to. The \texttt{issuer-uri} must be set correctly, otherwise the application won't be able to start successfully. This also happens when the OIDC provider is not reachable. The reason is, that the issuer-uri is used by the application to retrieve vital configuration metadata from the OIDC provider which is needed for the creation of automatic configuration. As a default, a \texttt{OpenID provider Configuration Request} is made to \texttt{"[specified issuer-uri]/.well-known/openid-configuration"}. This endpoint offers all the necessary configuration metadata, like \texttt{token\_endpoint}, \texttt{jwks\_uri}, \texttt{end\_session\_endpoint}, supported grant types and response types, supported signing and encryption algorithms etc \cite{OpenIDConnectDiscovery}.%in intro verschieben??? dann hier nur verweis

%ist das principal propagation im sinn von yarygina? könnte passen.
The Gateway must also be able to attach access tokens to any authorized request that will be routed to a downstream resource server. Spring Security offers a \texttt{TokenRelayGatewayFilterFactory} which fetches the access token from the authenticated user and attaches an \texttt{Authorization} header to the request with the value \texttt{"Bearer" + token}. The fastest way to add the \texttt{TokenRelayGatewayFilterFactory} is certainly to add a \texttt{default-filter} to the route configuration in the \texttt{application.yml} file as shown in listing \ref{lst:tokenrelay}. This filter will then be applied to all configured routes. Alternatively, the filter can be configured for specific routes by adding \texttt{- TokenRelay=} to \texttt{filters} \cite{TokenRelayGatewayFilterFactory}.

\begin{lstlisting}[frame=lines, caption=Route configuration with token relay default filter in the Gateway's application.yml file, captionpos=b, label = lst:tokenrelay, language=Java, showstringspaces=false]
spring:
  application:
    name: gateway2
  cloud:
    gateway:
      routes:
      
      	[...]

        - id: milk
          uri: ${MILK}
          predicates:
            - Path=/milk
          filters:
            - SetPath=/getmilk

      default-filters:
        - TokenRelay=
\end{lstlisting}

Security configuration for the gateway's endpoints can now be added in the way that is shown in listing \ref{lst:securitywebfilterchain}, taken from the reduced Teapot Gateway2. Because \texttt{/hellogateway} and \texttt{/hellotea/noauth} should remain open for testing purposes, this is taken care for with \texttt{permitAll()} before configuring all remaining endpoints as open for authenticated users only, with \texttt{.authorizeExchange().anyExchange().authenticated()}. With \texttt{oauth2login()} the users will be authenticated so they can have access to the protected endpoints \cite{rozaWebClientOAuth2Support2019}. 
 
\begin{lstlisting}[frame=lines, caption=SecurityWebFilterChain for configuration of the OAuth2 client's behaviour. Code example from the reduced Teapot Gateway2, captionpos=b, label = lst:securitywebfilterchain, language=Java, showstringspaces=false]
@Configuration
@EnableWebFluxSecurity
public class Gateway2SecurityConfiguration {
    @Bean
    public SecurityWebFilterChain springSecurityWebFilterChain(
    			ServerHttpSecurity http,
    			ServerLogoutSuccessHandler handler) {
                .authorizeExchange()
                .pathMatchers("/hellogateway", "/hellotea/noauth")
                .permitAll()
            .and()
                .authorizeExchange()
                .anyExchange()
                .authenticated()
            .and()
                .oauth2Login()
            .and()
                .logout()
                .logoutSuccessHandler(handler);
        return http.build();
    }
\end{lstlisting}

%folgender absatz: ServerlogoutSuccessHander für reactive, LogoutSuccessHandler für servlet... Gateway as Client ist reactive -> ServerLogoutSuccessHandler. teas rs ist servlet, gateway as rs ist auch reactive. lohnt sich teas umschreiben auf reactive noch?
One particular aspect here is the \texttt{logoutSuccessHandler} call that gets an \texttt{ServerLogoutSuccessHandler} object as an argument. A separate bean, as shown in listing \ref{lst:logoutSuccessHandler}, has to be written in order to make this work properly. The \texttt{OidcClientInitiatedServerLogoutSuccessHandler}, which implements the ServerLogoutSuccessHandler interface, takes care of the logout process and calls the Keycloak Server's \texttt{end\_session\_endpoint} for this user \cite{AdvancedConfigurationSpring}, \cite{HowFixKeycloak2022}, \cite{rozaSpringSecurityOpenID2017}. This process is defined in OpenID Connect Session Management 1.0 as the \textit{RP-Initiated Logout}, where RP stands for relying party \cite{jonesOpenIDConnectRPInitiated2022}. Because Keycloak provides Session Management and  Discovery, the \texttt{end\_session\_endpoint} URL can be configured automatically with Spring Boot. The \texttt{postLogoutRedirectUri} is the URI that the user will be redirected to after having logged out successfully. User logout can be initiated by a \texttt{GET} or \texttt{POST} request to \texttt{{base-url}/logout} as default. The \texttt{/logout} endpoint does not need to be permitted explicitly in the filter chain \cite{rozaSpringSecurityOpenID2017}. Figures \ref{fig:logout_requests} and \ref{fig:logout_endsessionurl} show the process in the Firefox networks analytics tool. First, a POST request is sent to the Teapot Gateway's \texttt{logout} endpoint, then a redirect follows to \texttt{http://host.docker.internal:10001/realms/teapot/protocol/openid-connect/logout}, which is the \texttt{end\_session\_endpoint} at the Keycloak, together with the \texttt{id\_token\_hint} and the \texttt{post\_logout\_redirect\_uri} as query parameters. The \texttt{id\_token\_hint} is used to let Keycloak know for which user the session should be cancelled. The \texttt{post\_logout\_redirect\_uri} is open to anonymous users and doesn't require authorization.

%listing: , according to \cite{HowFixKeycloak2022} fehlt!!! einfügen hat probleme gemacht. why?
\begin{lstlisting}[frame=lines, caption=Logout success handler. Code example from the Teapot Gateway according to \cite{rozaSpringSecurityOpenID2017}, captionpos=b, label = lst:securitywebfilterchain, language=Java, showstringspaces=false]
    @Bean
    public ServerLogoutSuccessHandler keycloakLogoutSuccessHandler(ReactiveClientRegistrationRepository repository) {
        OidcClientInitiatedServerLogoutSuccessHandler oidcClientInitiatedServerLogoutSuccessHandler = new OidcClientInitiatedServerLogoutSuccessHandler(repository);
        oidcClientInitiatedServerLogoutSuccessHandler.setPostLogoutRedirectUri("https://orf.at");
        return oidcClientInitiatedServerLogoutSuccessHandler;
    }
\end{lstlisting} 

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/logout_requests}
	\caption{POST request to the \texttt{\\logout} endoint of the Teapot Gateway and redirection to Keycloak's \texttt{end\_session\_endpoint}}
	\label{fig:logout_requests}
\end{figure}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/logout_endsessionurl}
	\caption{The \texttt{end\_session\_endpoint} with query parameters}
	\label{fig:logout_endsessionurl}
\end{figure}


With Spring Boot, a \texttt{GatewayApplication.java} class is created automatically, that contains the \texttt{main} method. With this setup the Gateway application is already fully functional and able to route requests to a resource server together with an access token after the user has authenticated successfully.

An additional feature in the Teapot Gateway is the \texttt{/hellogateway} endpoint which returns a string with a greeting to the user after reading the user's name from the authentication principal . This is possible without adding an additional dependency because \texttt{Spring Cloud Gateway} already contains the \texttt{spring-boot-starter-webflux} dependency.

\begin{lstlisting}[frame=lines, caption=Reading the user's name from the authentication principal., captionpos=b, label = lst:tokenrelay, language=Java, showstringspaces=false]
@RestController
public class GatewayController {
    @GetMapping("/hellogateway")
    public String greet(@AuthenticationPrincipal OAuth2User principal) {
        return "Hello, " + principal.getName() + ", from Gateway";
    }
}
\end{lstlisting}

% \texttt{spring-boot-starter-web} starter dependency also has an automatically embedded TomCat webserver (for reactive web applications there is also the \texttt{spring-boot-starter-webflux} module which comes with Netty as default). - der satz passt hier so nicht, weil gateway ja webflux hat

\subsection{The Resource Server}
\label{sub:gateway-rs}
The OAuth2 Resource Server recieves and validates the access token and, if the token is valid, grants access to the requested resource (see section \ref{sec:oauth2}). The basic steps to configure a resource server with Spring Boot are not very different from the configuration of the OAuth2 client: implementation of the necessary dependencies in the \texttt{pom.xml} file, configuration of the \texttt{issure-uri}, or optionally the \texttt{jwk-set-uri} in \texttt{application.properties} or \texttt{application.properties} and overriding the default \texttt{SecurityFilterChain} with a customized one \cite{wagdeOAuthResourceServer2020}.

The minimal dependencies needed are \texttt{spring-security-oauth2-resource-server}, which contains the resource server support, and \texttt{spring-security-oauth2-jose}, which allows the resource server to decode JWTs, and is therefore crucial for the application's ability to validate JWT access tokens \cite{OAuthResourceServer}. Both are included in the \texttt{spring-boot-starter-oauth2-resource-server} starter dependency. OAuth2 bearer token authentication is possible with JWTs or with opaque tokens (see section \ref{???}). The Teapot project works with JWT.

The authorization process when a request for a protected resource comes in without an access token, goes like this \cite{OAuthResourceServerb}:

\begin{itemize}
\item An unauthenticated request comes in from the User
\item The \texttt{AuthorizationFilter} throws an \texttt{AccessDeniedException}
\item The \texttt{ExceptionTranslationFilter} initiates \textit{Start Authentication} and activates the
\texttt{BearerTokenAuthenticationEntryPoint} to send a \texttt{WWW-Authenticate: Bearer} header (see figure \ref{fig:www-authenticate}
\item Now the client can retry the request with the bearer token.
\end{itemize}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/bearertokenauthenticationenttrypoint}
	\caption{The BearerTokenAuthenticationEntryPoint sends a \texttt{WWW-Authenticate : Bearer} back to the requesting client \cite{BearerTokenAuthenticationEntryPointJava2023}}
	\label{fig:bearertokenauthenticationenttrypoint}
\end{figure}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/www-authenticate}
	\caption{\texttt{WWW-Authenticate} header in the response to an unauthorized request to the resource server}
	\label{fig:www-authenticate}
\end{figure}

When the request comes with a bearer token, the \texttt{BearerTokenAuthenticationFilter} extracts the token from the \texttt{HttpServletRequest} and creates a \texttt{BearerTokenAuthenticationToken}, which implements the \texttt{Authentication} interface \cite{BearerTokenAuthenticationTokenSpringsecuritydocsAPI} . The \texttt{Authentication} represents the authenticated user and contains (among others) a \texttt{principal}, which represents an individual, corporation, login id or any other entity \cite{PrincipalJavaDevelopment}, crentials and authorities \cite{AuthenticationSpringsecuritydocsAPI}. An \texttt{authority} is an instance of \texttt{GrantedAuthority} and usually represents coarse-grained permission, for example \texttt{role} or \texttt{scope} \cite{ServletAuthenticationArchitecture} (for more details about role-mapping, see section \ref{sub:role-mapping}). The \texttt{credentials} in this case contain the access token. The \cite{Authentication} is then passed to the \texttt{AuthenticationManager}. The \texttt{AuthenticationManager} is selected by the \texttt{AuthenticationManagerResolver} based on the \texttt{HttpServletRequest}, either for JWT, like in this case, or for opaque tokens. The \texttt{AuthenticationManager} authenticates the \texttt{BearerTokenAuthenticationToken} which means in this case, that it validates the token, stored under \texttt{credentials}. Depending on wheather authentication fails (the token is not valid) or is successfull, the \texttt{SecurityContextHolder} is cleared out and the \texttt{AuthenticationEntryPoint} will send the \texttt{WWW-Authenticate} header again, or the \texttt{SecurityContextHolder} is set the  with the Authentication object and the \texttt{FilterChain} continues \cite{OAuthResourceServerb}.

Like with the OAuth2 client, the resource server needs the \texttt{issuer-uri} to be configured correctly. At startup the resource server application has to deduce the authorization server's configuration endpoint. With only the \texttt{issuer-uri} given, it is important that one of a set of specific configuration endpoints is supported. With the Keycloak server, the configuration endpoint is \texttt{http://localhost:10001/realms/teapot/.well-known/openid-configuration}. This endpoint can now be queried for the \texttt{jwks-url} property and for supported algorithms. With this information, the application can configure the validation strategy which will in the next step query the \texttt{jwks-url} for the public key set of these algorithms. Lastly, the validation strategy will be configured to check the \texttt{iss} claim of recieved JWT access tokens against the given \texttt{issuer-uri}. For this reason the authorization server must be up and reachable, otherwise the resource server application will fail at startup \cite{OAuthResourceServer}.

In order to allow the application to start independently when the authorization server is not yet reachable, the \texttt{jkw-set-uri} can be configured explicitly, because it doesn't need to call the issuer-uri in order to find out the end point to retrieve the JWKS \cite{wagdeOAuthResourceServer2020}. In the Teapot project's \texttt{application.properties} file, this looks like in listing \ref{lst:rs-yml}. Still, with the \texttt{issuer-uri} provided, the \texttt{iss} claim in incoming JWTs will be validated against the given issuer \cite{OAuthResourceServer}.

When a request is sent to a protected endpoint at the resource server, it uses the public key from the authorization server to validate the signature and match it with the token. Then the \texttt{exp} and \texttt{iss} claims in the token are checked \cite{OAuthResourceServer}. For a more differentiated authorization policy it is possible to define scope and roles in Keycloak. In order to use them, custom claims have to be converted into authorities at the resource server (see section \ref{sub:role-mapping}).

\begin{lstlisting}[style=yaml, frame=lines, caption=\texttt{issuer-uri} and \texttt{jwk-set-uri} in the Tea service's application.properties file, captionpos=b, label=lst:rs-yml, language=Java, showstringspaces=false]
spring:

[...]  

  security:
    oauth2:
      resource-server:
        jwt:
          issuer-uri: ${KEYCLOAK}/realms/teapot
          jwk-set-uri: ${KEYCLOAK}/realms/teapot/protocol/openid-connect/certs
\end{lstlisting}

Like with the client (section {section \ref{sub:gateway-cl}} the \texttt{SecurityFilterChain} bean can be overridden for custom configuration. A minimal configuration of the \texttt{SecurityFilterChain} can look like in listing \ref{lst:rs-secfilterchain}. The two endpoints \texttt{/teas/hello/noauth} and \texttt{/teas/create} are open for convenience during experimental development, while all other endpoints are protected and can only be accessed with a valid access token. \texttt{oauth2ResourceServer} gets a \texttt{Customizer} parameter of type \texttt{OAuth2ResourceServerConfigurer}. With this customizer it is possible to specify that JWT bearer tokens should be supported. This will populate the beforementioned \texttt{BearerTokenAuthenticationFilter} which is responsible for processing the access token \cite{OAuth2ResourceServerConfigurerSpringsecuritydocsAPI}.

\begin{lstlisting}[frame=lines, caption=\texttt{SecurityFilterChain} configuration in the Tea service (resource server), captionpos=b, label = lst:rs-secfilterchain, language=Java, showstringspaces=false]
@Configuration
public class TeaSecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests().requestMatchers("/teas/hello/noauth", "/teas/create").permitAll()
                .anyRequest().authenticated();
        http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
        [...]
        return http.build();
    }
}
\end{lstlisting}

For the definition of authorities that are not provided in the original access token, the customized conversion from the JWT to an \texttt{Authentication} object can be supplied at this point as \texttt{ OAuth2ResourceServerConfigurer.JwtConfigurer.jwtAuthenticationConverter(Converter)} instead of \texttt{OAuth2ResourceServerConfigurer::jwt} \cite{OAuth2ResourceServerConfigurerSpringsecuritydocsAPI}.

Spring Security has CSRF protection enabled by default \cite{SpringBootReferencea}. Because the resource server relies on bearer token authentication, some authors in grey literature recommend making the session stateless  \cite{sandeepaUsingKeycloakSpring2023} and as a consequence to disable CSRF protection \cite{SpringaddonsSamplesTutorials}. This is only possible for resource servers, while clients that are consumed by browsers must always enable CSRF protection because they rely on session cookies \cite{lodderstedtOAuthSecurityBest2023}. This can be configured in the \texttt{SecurityFilterChain} bean as shown in listing \ref{lst:rs-stateless-csrf}.

%hat eigenen yaml-style, siehe ganz oben! farben sind mit kommentaren möglich. linebreak ist dort momentan absichtlich deaktiviert.
\begin{lstlisting}[frame=lines, caption=Stateless session and disabled CSRF protection configured in the\texttt{SecurityFilterChain} bean in the Tea service (resource server), captionpos=b, label = lst:rs-stateless-csrf, language=Java, showstringspaces=false]
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        [...]
        http.sessionManagement((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .csrf().disable();
        return http.build();
    }
\end{lstlisting}

The actual resources that the Tea service is holding are \texttt{Tea} objects that are stored in a MongoDB database. However, the implementation of object relational mapping with spring boot lies beyond the scope of this thesis, therefore further details are omitted.

%!!! Quelle! siehe wfp1 trello, notfalls weglassen, weil eh selbst ausprobiert?
The gateway in a MSA can also be implemented as a resource server instead of being a client. In this case it is necessary that any client sending a request to the gateway is able to provide the appropriate access token because it will not take care of redirecting the user to the OP for authentication. This version has been implemented for the purpose of answering the second research question of this thesis about the positioning of the oauth2 client. The steps to configure the gateway as a client are mostly covered already in this section and in section \ref{sub:gateway-cl} and will therefore be omitted at this point.
% tokenrelay hat hier gestört, nicht klar warum.
% spring cloud gateway kann nur webflux?

\subsection{Role mapping with Keycloak and Spring Boot Resource Server}
\label{sub:role-mapping}
In the event that an intruder manages to steal an access token, or if a member of the organization tries to perform operations that they are not entitled to, the possibile damage can be significantly reduced by defining roles with different privileges. In the example of the Teapot this means that someone with a basic user role is not authorized to perform any operation that is not safe, like creating or deleting tea in the database. With a user token, only safe GET requests will be authorized by the resource server. Although this does not mean that no harm can be done by accessing information without altering it, the potential damage is limited compared to a misused access token for Teapot admins, who have privileges that enable them to erase the entire content of the Tea database. Of course this example is highly simplified and in real applications, even a basic user of the system might need to perform operations on the resource that would alter it, or have access to information not intended for anyone else, but the principle remains the same.
%RBAC ist anscheinend ein eigener standard, keine zeit, mich da einzuarbeiten. entweder nur ganz stark vereinfacht, oder so lassen.

Role mapping therefore allows to apply the principle of least privilege (PoLP), which means that users only have the privileges necessary to perform what is inherent to their role, but nothing else (!!! Quelle). Figure \ref{fig:keycloak-client-roles} depicts the roles for the Teapot Gateway client, with their privileges described as defined in the Tea resource server (see listing \ref{lst:roles-secfilterchain}.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-realm-roles}
	\caption{Roles in the Teapot realm with the custom \texttt{tea\_admin} and \texttt{tea\_user} roles.}
	\label{fig:keycloak-realm-roles}
\end{figure}

%Keycloak supports different kinds of access control (ACAB, RBAC, etc.)... https://www.keycloak.org/docs/latest/authorization_services/
With Keycloak there is the option to define realm roles and/or client roles. Realm roles can be composite by being associated to other realm roles or client roles \cite{ServerAdministrationGuide}. Figure \ref{fig:keycloak-client-roles} shows the defined client roles for the Teapot Gateway, while figure \ref{fig:keycloak-realm-admin-associated-roles} shows one of the composite realm roles, \texttt{tea\_admin} and it's associated client roles, \texttt{admin}, \\texttt{user} and \texttt{privileged\_user} which belong to the \texttt{teapot-gateway} client. %realm user ist auch noch dabei

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-client-roles}
	\caption{Example of client roles defined in the Keycloak admin console}
	\label{fig:keycloak-client-roles}
\end{figure}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-realm-admin-associated-roles}
	\caption{Example of a composite realm role and it's associated client role in the Keycloak admin console}
	\label{fig:keycloak-realm-admin-associated-roles}
\end{figure}

Keycloak includes these roles in the access token in a \texttt{realm\_access} or \texttt{resource\_access} claim respectively. The access token for a user with the \texttt{tea\_admin} realm role and the \texttt{admin} client role is shown in figure \ref{fig:keycloak-access-token-aud-roles}. The \texttt{realm\_access} contains only the \texttt{tea\_admin} role (the realm role) and \texttt{resource\_access} contains all associated roles for the \texttt{teapot-client}.

As we can see, the access token does not contain \texttt{authority} claims. The \texttt{realm\_access} or \texttt{resource\_access} access claims are specific to Keycloak (!!! Quelle). Spring Security allows to check for authorities inside the \texttt{authentication} object, but it provides no means by default to check specifically for the access claims provided by a Keycloak access token. This means that these roles have no effect on the authorization process, unless an authority converter is added. A converter translates specific claims in the access token to an \texttt{authority} in order to distinguish roles in authorization. Listing \ref{fig:roles-authorities-converter} shows how the roles can be extracted from the specific claims in the access token. They are returned as a list of authorities and can be checked in the \texttt{SecurityFilterChain} by calling the \texttt{hasAuthority()} method. Spring Security also offers the \texttt{hasRole()} method, which checks for roles specifically. Roles are defined in Spring Security by the \texttt{ROLE\_} prefix !!! Quelle!. This prefix has to be added in the conversion process as well, as shown in listing \ref{fig:roles-authorities-converter}, line 20. Spring Security provides a default \texttt{JwtAuthenticationConverter} for creating a \texttt{Authentication} from a \texttt{JWT}. This converter can be replaced by any class implementing \texttt{Converter<Jwt, AbstractAuthenticationToken>} \cite{OAuthResourceServer}. Listing \ref{lst:roles-converter} shows the custom converter that is used in the Tea resource server. It returns a \texttt{JwtAuthenticationToken} which inherits from \texttt{AbstractOAuth2TokenAuthenticationToken} and contains the extracted realm roles and client roles from the access token as authorities. As it turned out, with the converter code proposed by \cite{ch4mpAnswerUseKeycloak2022} it is important that the profile scope is included in the access token, so that Keycloak will automatically also add further profile information, including the \texttt{preferred\_username} path to the token. As an alternative the try-catch block was added, so that the \texttt{Authentication} is created only with the value of the \texttt{sub} claim.

% !!! für claimpath in access token \cite{ch4mp...}
%		<dependency>
%            <!-- used when converting Keycloak roles to Spring authorities -->
%            <groupId>com.jayway.jsonpath</groupId>
%            <artifactId>json-path</artifactId>
%        </dependency>
        
        
\begin{lstlisting}[frame=lines, caption=Extraction of client roles and realm roles from Keycloak access token and conversion to granted authorities according to \cite{ch4mpAnswerUseKeycloak2022}. Simplified and with addition of the \texttt{ROLE\_} prefix., captionpos=b, label=lst:roles-authorities-converter, language=Java]
@RequiredArgsConstructor
class JwtGrantedAuthoritiesConverter implements Converter<Jwt, Collection<? extends GrantedAuthority>> {

    @Override
    @SuppressWarnings({"rawtypes", "unchecked"})
    public Collection<? extends GrantedAuthority> convert(Jwt jwt) {
        return Stream.of("$.realm_access.roles", "$.resource_access.*.roles").flatMap(claimPaths -> {
                    Object claim;
                    try {
                        claim = JsonPath.read(jwt.getClaims(), claimPaths);
                    } catch (PathNotFoundException e) {
                        return Stream.empty();
                    }
                    final var firstItem = ((Collection) claim).iterator().next();
                    if (firstItem instanceof String) {
                        return (Stream<String>) ((Collection) claim).stream();
                    }
                    if (Collection.class.isAssignableFrom(firstItem.getClass())) {
                        return (Stream<String>) ((Collection) claim).stream().flatMap(item -> ((Collection) item).stream()).map(String.class::cast);
                    }
                    return Stream.empty();
                })
                .map(authority -> new SimpleGrantedAuthority("ROLE_" + authority))
                .map(GrantedAuthority.class::cast).toList();
    }
}
}\end{lstlisting}

\begin{lstlisting}[frame=lines, caption=Custom converter to set the extracted granted authorities from the access token in the new \texttt{Authentication} according to \cite{ch4mpAnswerUseKeycloak2022} with added try/catch blocks, captionpos=b, label= lst:roles-converter, language=Java, showstringspaces=false]
@Component
@RequiredArgsConstructor
class SpringAddonsJwtAuthenticationConverter implements Converter<Jwt, JwtAuthenticationToken> {

    @Override
    public JwtAuthenticationToken convert(Jwt jwt) {
        final var authorities = new JwtGrantedAuthoritiesConverter().convert(jwt);
        final String username;
        try {
            username = JsonPath.read(jwt.getClaims(), "preferred_username");
            return new JwtAuthenticationToken(jwt, authorities, username);
        } catch (PathNotFoundException e) {
            return new JwtAuthenticationToken(jwt, authorities);
        }
    }
}
\end{lstlisting}

The \texttt{SecurityFilterChain} bean can now be overridden in a way that access to different endpoints of the service is granted or not, depending on the role authority extracted from the access token of the user that requests a resource. The custom jwt converter from listing \ref{lst:roles-converter} is given as parameter to the \texttt{oauth2resourceServer} overload method. In listing \ref{lst:roles-secfilterchain}, the \texttt{/teas/admin} endpoint is open for realm admins, while the \texttt{/teas/create} and \texttt{teas/delete/*} endpoints are open for client admins specifically. A user with the realm role \texttt{tea\_admin} has therefore access to all protected endpoints because \texttt{tea\_admin} is a composite role that also contains the three client roles. A user with only the client \texttt{admin} role assigned would not have access to \texttt{/teas/admin}, but can still access other endpoints. Because the client admin is not a composite role, the corresondent authority must be allowed explicitly in addition to the respective user roles (see lines 21-25 in figure \ref{lst:roles-secfilterchain}).%nicht best practice -> hinweis auf acab etc.?

\begin{lstlisting}[frame=lines, caption=, captionpos=b, label=lst:roles-secfilterchain, language=Java, showstringspaces=false]
@RequiredArgsConstructor
@Configuration
@EnableWebSecurity
public class TeaSecurityConfiguration {
    public static final String REALM_ADMIN = "tea_admin";
    public static final String CLIENT_ADMIN = "admin";
    public static final String REALM_USER = "tea_user";
    public static final String CLIENT_USER = "user";
    public static final String CLIENT_PRIVILEGED_USER = "privileged_user";

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, Converter<Jwt, ? extends AbstractAuthenticationToken> jwtAuthenticationConverter) throws Exception {
        http
                .authorizeHttpRequests().requestMatchers("/teas/hello/noauth")
                .permitAll()
                .requestMatchers("/teas/admin")
                .hasRole(REALM_ADMIN)
                .requestMatchers("/teas/create", "/teas/delete/*")
                .hasRole(CLIENT_ADMIN)
                .requestMatchers("/teas/maketea/special")
                .hasAnyRole(CLIENT_PRIVILEGED_USER, CLIENT_ADMIN)
                .requestMatchers("/teas/maketea/*", "/teas/hello/user")
                .hasAnyRole(CLIENT_USER, CLIENT_PRIVILEGED_USER, CLIENT_ADMIN)
                .requestMatchers("/teas/getall")
                .hasAnyRole(REALM_USER, REALM_ADMIN, CLIENT_ADMIN)
            .anyRequest().authenticated();
        http.oauth2ResourceServer().jwt().jwtAuthenticationConverter(jwtAuthenticationConverter);
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
        http.csrf().disable();
        return http.build();
    }
}
\end{lstlisting}

\section{Load testing with JMeter}
\label{sec:loadtesting-jmeter}

To compare the different client positions, load testing was performed for the two variants and for a third version of the Teapot system without any access control, to relate the results.

The load testing was performed with Apache JMeter and the services were deployed with docker compose on the same machine. All testing was carried out on a Lenovo Thinkpad T490s with a Intel\textregistered Core\texttrademark  i78665U CPU, 1.9 GHz Base Frequency, 4,8 GHz Max Turbo Frequency and 4 Cores. The operating system was Microsoft Windows 11 Pro.

!!! heap!

For testing purposes, only the minimal implementation without role-mapping was used and only the gateway was involved, because the process from the moment when the authentication is done and the request is routed to the resource server is the same in all scenarios. Test requests were sent to the gateway's \texttt{/helloauth} endpoint. For authentication in the first case, user login was first triggered via the browser so that the client would send a session cookie to the browser and store the user's access token. This session cookie was extracted and sent with each request to the client-gateway. In the second case, the gateway as resource server expects an access token, so this token was generated with Postman and sent with each request.

Testing parameters were the number of threads (which simulate the number of users), a \textit{ramp-up period} of 0, which means that all threads were started together and a \textit{loop count} of 1, so that each thread will send the request only once. The tests were performed in several rounds for 100 up to 500 concurrent users where 50 users were added to each round. For higher numbers of users a part of the requests started to fail.

The JMeter testscripts were prepared in the JMeter GUI and a Powershell script was created to start the tests in non-gui mode. For the comparison, the average response times were collected from the HTML dashboard generated by jmeter for each testround.
Load testing results are presented and discussed in section \ref{sec:response-times}.

\section{Code Analysis - FEHLT}
\label{code-analysis}
LoC
+ Sonarqube Ergebnisse?

\chapter{Results and Discussion} % evt. umbenennen in discussion
\label{chap:results}

...

\section{Compliance with OAuth2 and OIDC specifications}
\label{sec:conformance}

For the implementation presented in chapter \ref{chap:implementation}, functionality and compliance to OAuth2 and OIDC specifications was tested with Postman and Wireshark.

When trying to access the protected resource (the list of available Teas) via the gateway in it's client function at \texttt{http:localhost:8181/listteas} and a Firefox browser as user agent, the following requests and responses could be captured:

\begin{enumerate}
\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET http://localhost:8181/listteas}
\linebreak Unauthenticated user wants to view a list of teas and sends request to dedicated endpoint at the gateway (client)
\linebreak
$\leftarrow$ \texttt{302 Found Location: /oauth2/authorization/keycloak-gateway-client}
\linebreak Gateway refers the user to a different endpoint at the gateway

\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET /oauth2/authorization/keycloak-gateway-client}
\linebreak User agent sends request to the new endpoint
\linebreak
$\leftarrow$ \texttt{302 Found  [truncated]Location: http://host.docker.internal:10001/realms/teapot/protocol/openid-connect/auth...}
\linebreak \texttt{Request URI Query Parameter: response\_type=code}
\linebreak \texttt{Request URI Query Parameter: client\_id=teapot-gateway}
\linebreak \texttt{Request URI Query Parameter: scope=openid}
\linebreak \texttt{Request URI Query Parameter: state=FczD4rvwKxMMyYRC0joaa-oAr-GMbaG2rbuW76gE72k\%3D}
\linebreak \texttt[Request URI Query Parameter: truncated]{redirect\_uri=http://localhost...}
\linebreak \texttt{nonce= omitted by truncation?}
\linebreak Gateway refers user agent to Keycloak's authorization endpoint with the authorization request

\item
\texttt{Source Port: 50966, Dest. Port: 10001
\linebreak $\rightarrow$ [truncated]GET /realms/teapot/protocol/openid-connect/auth...}
\linebreak \texttt{Request URI Query Parameter: response\_type=code}
\linebreak \texttt{Request URI Query Parameter: client\_id=teapot-gateway}
\linebreak \texttt{Request URI Query Parameter: scope=openid}
\linebreak \texttt{Request URI Query Parameter: state=FczD4rvwKxMMyYRC0joaa-oAr-GMbaG2rbuW76gE72k\%3D}
\linebreak \texttt{Request URI Query Parameter: redirect\_uri=http://localhost:8181/login/oauth2/code/keycloak-gateway-client}
\linebreak \texttt{Request URI Query Parameter: nonce=BVUZ0gzd1P-FjEqiFWv8gLspnEEdaOpvvqm3hgiAriI}
\linebreak User agent sends the client's authorization request to Keycloak's authorization endpoint (query parameters omitted)
\linebreak
$\leftarrow$ \texttt{200 OK  (text/html)} (Keycloak Login Form Page)
\linebreak Keycloak responds with the login page to authenticate the user
\linebreak ---Additional requests to load login page omitted---

\item
\texttt{Source Port: 50971, Dest. Port: 10001
\linebreak $\rightarrow$ [truncated]POST /realms/teapot/login-actions/authenticate...}
\linebreak (request query parameters omitted)
\linebreak \texttt{Form item: "username" = "ula"}
\linebreak \texttt{Form item: "password" = "pass"}
\linebreak \texttt{Form item: "credentialId" = ""}
\linebreak User sends login data (username and password in payload)
\linebreak
$\leftarrow$ \texttt{302 Found  [truncated]Location: http://localhost:8181/login/oauth2/code/keycloak-gateway-client...}
\linebreak \texttt{Set-Cookie: KEYCLOAK\_SESSION=teapot/9db57273-f45d-440f-910e-8dc764c3bcb0/4165bd59-749c-4ed3-a210-ecd4a6f928f5; Version=1; Expires=Fri, 16-Jun-2023 22:35:18 GMT; Max-Age=36000; Path=/realms/teapot/; SameSite=None; Secure}
\linebreak (more cookies omitted)
\linebreak
Keycloak sends the user agent back to the gateway with the authorization code and state parameters (see below for full list of parameters)

\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET [truncated]/login/oauth2/code/keycloak-gateway-client...}
\linebreak \texttt{Request URI Query Parameter: state=FczD4rvwKxMMyYRC0joaa-oAr-GMbaG2rbuW76gE72k\%3D}
\linebreak \texttt{Request URI Query Parameter: session\_state=4165bd59-749c-4ed3-a210-ecd4a6f928f5}
\linebreak \texttt{Request URI Query Parameter: code=c49d4ea6-01c0-4f30-8388-48f338bdbd20.4165bd59-749c-4ed3-a210-ecd4a6f928f5.672c0413-eba3-4481-abb5-27f75a71727e}
\linebreak
(User agent sends the code back to the gateway)

\item
\texttt{Source Port: 50976, Dest. Port 10001
\linebreak $\rightarrow$	POST /realms/teapot/protocol/openid-connect/token (application/x-www-form-urlencoded)}
\linebreak \texttt{Authorization: Basic dGVhcG90LWdhdGV3YXk6U2ZBN3RCZFM5V2RrVnozRFlHcG5NOTY3UkFZTUtFU2s}
\linebreak \texttt{Form item: "grant\_type" = "authorization\_code"}
\linebreak \texttt{Form item: "code" = "c49d4ea6-01c0-4f30-8388-48f338bdbd20.4165bd59-749c-4ed3-a210-ecd4a6f928f5.672c0413-eba3-4481-abb5-27f75a71727e"}
\linebreak \texttt{Form item: "redirect\_uri" = "http://localhost:8181/login/oauth2/code/keycloak-gateway-client"}
\linebreak Gateway sends token request to Keykloaks token endpoint, with grant type, code and redirect-uri in the payload
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak \texttt{"access\_token":} (value omitted)
\linebreak \texttt{"expires\_in": "36000"}
\linebreak \textbf{"refresh\_expires\_in": "1800"}
\linebreak \texttt{"refresh\_token":} (value omitted)
\linebreak \texttt{"token\_type": "Bearer"}
\linebreak \texttt{"id\_token":} (value omitted)
\linebreak \texttt{"not-before-policy": "0"}
\linebreak \texttt{"session\_state": "4165bd59-749c-4ed3-a210-ecd4a6f928f5"}
\linebreak \texttt{"scope": openid profile email}
\linebreak Keycloak sends token response (in payload) to the gateway

\item
\texttt{Source Port: 50977, Dest. Port: 10001
\linebreak $\rightarrow$	GET /realms/teapot/protocol/openid-connect/certs}
\linebreak The gateway requests the JWKS from Keycloak
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak Keycloak returns JWKS in payload (omitted)

\item
\texttt{Source Port: 50976, Dest. Port: 10001
\linebreak $\rightarrow$ GET /realms/teapot/protocol/openid-connect/userinfo}
\linebreak \texttt{ [truncated]Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJHV...}
\linebreak Gateway requests additional user information from Keykloak's userinfo endpoint with the freshly issued access token
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak Keycloak returns user info (omitted)


\item
\texttt{Source Port: 8181, Dest. Port: 50965
\linebreak $\leftarrow$ 302 Found Location: /listteas
}
\linebreak Gateway refers user to it's own \texttt{/listteas} endpoint a second time

\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET /listteas}
\linebreak Browser sends new request to gateway's \texttt{/listteas} endpoint
\linebreak
$\leftarrow$ 

\item
\texttt{Source Port: 50978, Dest. Port: 8184
\linebreak $\rightarrow$ GET /teas/getall}
\linebreak \texttt{[truncated]Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJHVGZ5e...}
\linebreak Gateway forwards request for list of teas to Tea service with the access token in the \texttt{Authorization} header 
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak
Tea service responds to gateway with list of teas in payload (omitted)

\item
\texttt{Source Port: 8181, Dest. Port: 50965 $\leftarrow$ 200 OK , JavaScript Object Notation (application/json)}
\linebreak Gateway forwards the Tea service's response to the user agent.
\end{enumerate}

The protocol is HTTP 1.1 and host is localhost where not marked differently.

We can see that the steps of the authorization code flow match with the OAuth2 specification. The authorization code is passed through via the user agent to the client who then trades it for the access token with the AZ. Authorization request, token request and token response are present and the access token is passed on from the client to the resource server as bearer token in the \texttt{Authentication} header.

The authorization/authentication request also contains the required parameters \texttt{response\_type}, \texttt{client\_id}, \texttt{redirect\_uri} and \texttt{scope} with \texttt{openid} as the value, where the last two parameters are required by OIDC. The \texttt{code\_challenge} parameter is missing. It is not required when the optional \texttt{nonce} parameter is used, which is the case here, but still recommended by the OAuth2 specification. Also the recommended \texttt{state} parameter is present.

The token request is sent to Keycloak's token endpoint and contains again the \texttt{client\_id} and \texttt{grant\_type} as required. The client authenticates during the token request with basic authentication. This is possibly by definition of OAuth2 and it was a choice during the implementation. However, Spring Security and Keycloak both support other methods of client authentication, for example with a signed JWT \cite{AuthorizationServicesGuide}, \cite{ClientAuthenticationSupport}. The value in the authorization header is the base64-encoding of \texttt{client\_id:client\_secret}.

The token response also contains all required parameters, including the id token, since it is an OIDC token response. The \texttt{scope} parameter contains more scope strings than the requested \texttt{oidc} scope and is therefore required as well \cite{hardtOAuthAuthorizationFramework2023}. Other parameters are specific to Keycloak and are not covered in the specifications. The access token lifetime was intentionally configured to be longer than recommended for testing convenience.

The access token itself turned out to show some flaws. In the wireshark capture shown above it is truncated and can not be anaylzed, however when examining other access tokens issued by Keycloak, some faults become apparent: the media type in the \texttt{typ} header parameter is not \texttt{at+jwt} or \texttt{application/at+jwt} as required for OAuth2 JWT tokens. This special value is important for the distinction between access tokens and id tokens, to avoid that id tokens are accepted as access tokens \cite{bertocciJSONWebToken2021}. In fact, the attempt to request Tea from the Tea service with the id token instead of an access token was successful with this implementation (without role mapping). No configuration option could be found for Keycloak to change the token header, neither in the documentation nor by browsing through Keycloaks admin console. This does not mean that it is not possible, but it can be criticized that it is not as straightforward as it should be and the question remains why the required media type is not the default. As long as the access token's media type can not be changed, implementing it's validation on the resource server would not make sense. A related problem is the missing \texttt{aud} claim in the access token, which must be validated by the resource server, who must reject the request if it can not identify itself with the value \cite{bertocciJSONWebToken2021}. The \texttt{aud} claim can be set and configured in the Keycloak admin console by adding a scope mapper of the type \textit{Audience} type \cite{•}. Token validation with Spring Security can be configured with the \texttt{OAuth2TokenValidator} API \cite{OAuthResourceServer}. At the Tea service, this would look like shown in listing \ref{lst:aud-validation}. An example access token which now includes the required \texttt{aud} claim is shown in figure \ref{fig:keycloak-access-token-aud-roles}. Another required parameter not included by Keycloak by default is \texttt{client\_id}. Adding it to the token with a scope mapper can be done in a similar way as for the \texttt{aud} claim, although Keycloak doesn't seem to offer a preconfigured mapper for this purpose. However, the \texttt{azp} claim does indeed contain the client id by default and seems to fulfil a similar purpose.

\begin{lstlisting}[frame=lines, caption=Validator for the \texttt{aud} claim for the Tea resource server according to \cite{OAuthResourceServer}., captionpos=b, label = lst:aud-validation, language=Java, showstringspaces=false]
OAuth2TokenValidator<Jwt> audienceValidator() {
    return new JwtClaimValidator<List<String>>(AUD, aud -> aud.contains("tea"));
}
\end{lstlisting}

%scope strings must have meaning for resource in the aud claim -> not implemented

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-access-token-aud-roles}
	\caption{Example of an access token issued by the Keycloak server.}
	\label{fig:keycloak-access-token-aud-roles}
\end{figure}

The id token issued by Keycloak is inconspicuous in comparison. An example id token with additional user information is shown in figure \ref{fig:keycloak-id-token}. Including user profile information in the id token is optional and can be configured in the Keycloak admin console. The same is true for the information returned by the userInfo endpoint.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-id-token}
	\caption{Example of an id token issued by the Keycloak server.}
	\label{fig:keycloak-id-token}
\end{figure}


%!!! Keycloak (in der 20er version) und Spring Security unterstützen immer noch deprecated grant types! 

%refresh token auslassen weil komplett optional und nicht weiter genutzt.

% error responses weglassen!

%!!! besser nicht 100% vollständig! es kann auch einfach erwähnt werden, was getestet wurde und ob error responses entsprechen



%session\_state ist teil vom KEYCLOAK\_SESSION  cookie

%implementation: schwierig wegen deprecation (spring boot3, spring security, keycloak adapter) und nicht mehr aktuellen tutorials und documentations -> keycloak war am anfang noch am übergang und doc nicht up to date

%scaling: api gateway has the potential to become a bottleneck \cite{matarApproachEvaluatingPotential2023}  -> bff can mitigate this to a certain degree by desing by having several gateways, but also a basic API gateway should be duplicated at some point.

\section{Response times} % raufverschieben zu implementation
\label{sec:response-times}

!!! tests für die ganze runde fehlen! + erklären, was beim jeweiligen szenario passiert.
etwas andere parameter weil client nur in der gui mit 0 ramp up time testbar war

Load testing of the different gateway variants showed higher average response times for the gateway as resource server than for the gateway as client. The response times for the unprotected gateway were even lower, which can be expected because no endpoint protection mechanism is involved in the process. Figure \ref{fig:response-times} shows the average response times for all three variants.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/response-times}
	\caption{Average response times in milliseconds of the \texttt{/helloauth} endpoint of all three gateway variants.}
	\label{fig:response-times}
\end{figure}

The load testing experiment was repeated several times. Although the resulting numbers were not always the same as in the graph depicted in figure \ref{fig:response-times}, they showed consistently that the gateway has longer response times when it is implemented as resource server than in it's client implementation. This effect might even be stronger with a more thorough examination of the access token, when more parameters have to be checked before the token is accepted. Additionally, a frontend application that consumes the gateway's endpoints has to implement client functionality which includes occasional communication with the AZ, when the gateway is a resource server, which can only add to the total delay from the user's perspective.
%!!! Wenn alles nach best practice implementiert ist, könnte es sein, dass die zeiten nicht mehr in der reihenfolge liegen
%scaling...
%welche art von authentication zwischen gateway als rs und tea rs, könnte auch mtls sein z.B.
\section{Code complexity - FEHLT}
\label{complexity}

\chapter{Conclusion and Future Work}
\label{chap:conclusion}

In this thesis it has been investigated how authentication and authorization can be implemented in a MSA system according to OAuth2 and OIDC specifications with Spring Boot and Keycloak. The outcome was analyzed with Firefox, Postman and Wireshark to check, where the implementation complies with the specification and where further improvement is necessary. The results of this investigation made it apparent that most basic requirements can be fulfilled with very few configuration steps in the Keycloak admin console, such as creating a realm, a client and a user and by overriding the \texttt{SecurityFilterChain}  in the source code of the resource server and the client (when implemented as part of the MSA). While some requirements were omitted by choice for convenience during the development process, like not protecting communication between services with TLS, the absence of some other required features, like missing claims and their validation was revealed only upon further analysis of the generated requests and responses between the services. While it was possible to gather information about how to implement some of them, this was not the case for the wrong media type (\texttt{JWT} instead of \texttt{at+jwt}) in the \texttt{typ} header value of access tokens issued by Keycloak. As long as the media type can not be distinguished from the media type of id tokens, a check for the correct \texttt{typ} header value, which is required by RFC 9068, can not be implemented in the resource server without making it unfunctional.

Additionally, logout functionality was implemented, which is not defined in OAuth2 and only mentioned as optional in the OIDC core specification, therefore adherence to the specifications \cite{!!! https://openid.net/specs/openid-connect-session-1_0.html zotero hat gestreikt} was not analyzed. This could be a possible extension of this research.

Another not strictly required feature that was implemented is access control based on user roles, because having at least a minimum of differentiated access control is considered best practice for better security. Keycloak supports other, more fine-grained methods of access control, like attribute-based access control (ACAB), but the implementation, but the limitation on roles seemes sufficient as a proof of concept within the scope of this thesis. The implementation of ACAB can also be a suggestion for future work.

Gathering the necessary information for these further implementations was not always an easy task. One reason was the unfortunate timing of this research which started only a couple of months after the Keycloak adapters for Spring Boot had been deprecated in early 2022 \cite{DeprecationKeycloakAdapters}. These adapters had been in use for some years and most of the information and examples that were available online still referred to the usage of the Keycloak adapter, including the Keycloak documentation. A lot of trial and error experimentation was involved to find the correct configurations and it can be assumed that the presented state of implementation and configuration of the Teapot system can still be improved.

It is also clear that this thesis, while paying close attention to many details in the specifications was not sufficient to cover all the requirements in detail as it would be necessary for a secure production-ready implementation, not to mention recommendations and best practice. The presented implementation and considerations therefore cover only a selection, which leaves the implementation and analysis of further details for future work. Examples are using a recommended client authentication method like mTLS or JWT, using sender-constrained access tokens, using code challenge/PKCE in the authorization code flow and of course client communication must be secured with TLS (required by OAuth2).

Another suggestion for future work would be a more thorough and systematic security testing of the implementation. While some tests were performed manually, like using the id token as access token, manipulating the payload of the access token or sending invalid parameters in the authorization or token request, protection against other attacks was not tested systematically. The OAuth2 specification includes a list of threats and possible attacks and information about their mitigation.

\newpage
% --- Bibliography ------------------------------------------------------

%IEEE Citation [1]
\bibliographystyle{IEEEtran}
%for alphanumeric citation eg.: [ABC19]
%\bibliographystyle{alpha}

% List references I definitely want in the bibliography,
% regardless of whether or not I cite them in the thesis.

\newpage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{BA2}

\newpage

% --- List of Figures ----------------------------------------------------

\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures

% --- List of Code Listings ----------------------------------------------------

\addcontentsline{toc}{chapter}{List of Code Listings}
\lstlistoflistings

% --- List of Tables -----------------------------------------------------

\newpage
\addcontentsline{toc}{chapter}{List of Tables}
\listoftables

\end{document}
