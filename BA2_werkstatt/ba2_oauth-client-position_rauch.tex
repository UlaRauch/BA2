%----------------------------------------------------------------
%
%  File    :  thesis.tex
%
%  Authors :  Keith Andrews, IICM, TU Graz, Austria
%             Manuel Koschuch, FH Campus Wien, Austria
%			  Sebastian Ukleja, FH Campus Wien, Austria
% 
%  Created :  22 Feb 96
% 
%  Changed :  14 Oct 2020
%
%  For suggestions and remarks write to: sebastian.ukleja@fh-campuswien.ac.at
% 
%----------------------------------------------------------------

% --- Setup for the document ------------------------------------

%Class for a book like style:
\documentclass[11pt,a4paper,oneside]{scrbook}
%For a more paper like style use this class instead:
%\documentclass[11pt,a4paper,oneside]{thesis}

%input encoding for windows in utf-8 needed for Ä,Ö,Ü etc..:
\usepackage[utf8]{inputenc}
%input encoding for linux:
%\usepackage[latin1]{inputenc}
%input encoding for mac:
%\usepackage[applemac]{inputenc}

\usepackage[english]{babel}
% for german use this line instead:
%\usepackage[ngerman]{babel}

%needed for font encoding
\usepackage[T1]{fontenc}

% want Arial? uncomment next two lines...
%\usepackage{uarial}
%\renewcommand{\familydefault}{\sfdefault}

%some formatting packages
\usepackage[bf,sf]{subfigure}
\renewcommand{\subfigtopskip}{0mm}
\renewcommand{\subfigcapmargin}{0mm}

%For better font resolution in pdf files
\usepackage{lmodern}

\usepackage{url}

%\usepackage{latexsym}

\usepackage{geometry} % define pagesize in more detail


\usepackage{colortbl} % define colored backgrounds for tables

\usepackage{courier} %for listings
\usepackage{listings} % nicer code formatting
\lstset{basicstyle=\ttfamily,breaklines=true}

\usepackage{graphicx}
  \pdfcompresslevel=9
  \pdfpageheight=297mm
  \pdfpagewidth=210mm
  \usepackage[         % hyperref should be last package loaded
    pdftex, 		   % needed for pdf compiling, DO NOT compile with LaTeX
    bookmarks,
    bookmarksnumbered,
    linktocpage,
    pagebackref,
    pdfview={Fit},
    pdfstartview={Fit},
    pdfpagemode=UseOutlines,                 % open bookmarks in Acrobat
  ]{hyperref}
\DeclareGraphicsExtensions{.pdf,.jpg,.png}
\usepackage{bookmark}

\usepackage[title]{appendix}

%paper format
\geometry{a4paper,left=30mm,right=25mm, top=30mm, bottom=30mm}

% --- Settings for header and footer ---------------------------------
\usepackage{scrlayer-scrpage}
\clearscrheadfoot
\pagestyle{scrheadings}
\automark{chapter}

%Left header shows chapter and chapter name, will not display on first chapter page use \ihead*{\leftmark} to show on every page
\ihead{\leftmark} 	
%\ohead*{\rightmark}	%optional right header
\ifoot*{Ursula Rauch}		%left footer shows student name
\ofoot*{\thepage}		%right footer shows pagination
%---------------------------------------------------------------------

%--- additional packages necessary for table in results --------------
\usepackage[xcdraw]{xcolor}
\usepackage{lscape}
%-------------------------------------------------------------------- 

\usepackage{xcolor}

%New colors defined below
\definecolor{codeorange}{rgb}{1.00,0.45,0.00}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{codeorange},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codegreen},
  basicstyle=\ttfamily\small,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}
\lstset{style=mystyle}


\lstdefinestyle{yaml}{
  backgroundcolor=\color{backcolour},
  keywordstyle=\color{codeorange},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codegreen},
  basicstyle=\ttfamily\small,
  rulecolor=\color{black},
  string=[s]{'}{'},
  stringstyle=\color{codegreen},
  comment=[l]{:},
  commentstyle=\color{black},
  morecomment=[l]{-}
  breakatwhitespace=false,
  breaklines=false,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
 }

%----------------------------

%Start of your document beginning with title page
\begin{document}


% --- Main Title Page ------------------------------------------------
\begin{titlepage}
\frontmatter

\begin{picture}(50,50)
\put(-70,40){\hbox{\includegraphics{images/logo.png}}}
\end{picture}

\vspace*{-5.8cm}

\begin{center}

\vspace{6.2cm}

\hspace*{-1.0cm} {\LARGE \textbf{A prototype implementation of OAuth 2 and OpenID Connect in a Spring Boot Microservice Architecture with Keycloak Server and two possible positions of the OAuth client\\}}
\vspace{0.2cm}
%\hspace*{-1.0cm} Subtitle\\

\vspace{2.0cm}

\hspace*{-1.0cm} { \textbf{Bachelor Thesis\\}}

\vspace{0.65cm}

\hspace*{-1.0cm} Submitted in partial fulfillment of the requirements for the degree of \\

\vspace{0.65cm}

\hspace*{-1.0cm} \textbf{Bachelor of Science in Engineering\\}

\vspace{0.65cm}

\hspace*{-1.0cm} to the University of Applied Sciences FH Campus Wien \\
\vspace{0.2cm}
\hspace*{-1.0cm} Bachelor Degree Program: Computer Science and Digital Communications \\

\vspace{1.6cm}

\hspace*{-1.0cm} \textbf{Author:} \\
\vspace{0.2cm}
\hspace*{-1.0cm} Ursula Rauch \\

\vspace{0.7cm}

\hspace*{-1.0cm} \textbf{Student identification number:}\\
\vspace{0.2cm}
\hspace*{-1.0cm} 00514397 \\

\vspace{0.7cm}

\hspace*{-1.0cm} \textbf{Supervisor:} \\
\vspace{0.2cm}
\hspace*{-1.0cm} Leon Freudenthaler, BSc MSc \\

\vspace{0.7cm}

% Reviewer if needed
%\hspace*{-1.0cm} \textbf{Reviewer: (optional)} \\
%\vspace{0.2cm}
%\hspace*{-1.0cm} Title first name surname \\


\vspace{1.0cm}

\hspace*{-1.0cm} \textbf{Date:} \\
\vspace{0.2cm}
\hspace*{-1.0cm}!!!FEHLT NOCH!!! \\

\end{center}
\end{titlepage}

\newpage

\vspace*{16cm}
\setcounter{page}{1}

% --- Declaration of authorship ------------------------------------------
\hspace*{-0.7cm} \underline{Declaration of authorship:}\\\\
I declare that this Bachelor Thesis has been written by myself. I have not used any other than the listed sources, nor have I received any unauthorized help.\\\\
I hereby certify that I have not submitted this Bachelor Thesis in any form (to a reviewer for assessment) either in Austria or abroad.\\\\
Furthermore, I assure that the (printed and electronic) copies I have submitted are identical.
\\\\\\
Date: 15.01.2023 \hspace{6cm} Signature:\\

% --- Acknowledgement ------------------------------------------
\chapter*{Acknowledgement}
% Leon für gute Betreuung, FH-Freund*innen, Eltern für beherbergung und Futter, Mama für Korrekturlesen (und wer noch? Michi? Liest noch wer?), Restliche Familie und alle anderen, die mich während des Studiums moralisch supportet haben und aushalten haben müssen, dass ich eine Streberin geworden bin, die kaum noch Freizeit hat, Arbeitskolleg*innen, weil sie sich geduldig mein Gejammer anhören.


% --- English Abstract ----------------------------------------------------
\cleardoublepage
\chapter*{Abstract - FEHLT}
This thesis investigates different implementations of Authorization and Authentication with OpenID Connect (OIDC) and OAuth 2.0 (OAuth2) in a microservice architecture (MSA) environment...
% --- German Abstract ----------------------------------------------------
\cleardoublepage
\chapter*{Kurzfassung - FEHLT}
Diese Arbeit untersucht unterschiedliche Implementierungen von OpenID Connect (OIDC) bzw. OAuth 2.0 (OAuth2) im Kontext von \linebreak Microservice-Architekturen (MSA) ...

% --- Abbrevations ----------------------------------------------------
\chapter*{List of Abbreviations - CHECKEN}
\vspace{0.65cm}

\begin{table*}[htbp]
		\begin{tabular}{ll}
			!!!ALT! NICHT gebrauchte raushaun und manche noch konsequenter benutzen, z.b. AS und MA
			AS & Authorization Server \\
			BCP & Best Current Practice \\
			CRUD & Create Read Update Delete \\
			IANA & Internet Assigned Numbers Authority \\
			IETF & Internet Engineering Task Force \\
			JSON & JavaScript Object Notation \\
			JWT & JSON Web Token \\
			MA & Monolithic Architecture \\			
			MSA & Microservice Architecture \\
			mTLS & mutual Transport Layer Security \\
			OIDC & OpenID Connect \\
			RFC & Request for Comments \\
			OP & OIDC Provider \\
			POC & Proof of Concept \\
			PoLP & Principle of least privilege \\
			RSA & Rivest-Shamir-Adelman \\
			%SAML & Secturity Asertion Markup Language \\
			SSO & Single Sign-on \\
		\end{tabular}
\end{table*}

% --- Key terms ----------------------------------------------------
\newpage
\chapter*{Key Terms}
\vspace{0.65cm}

\begin{itemize}
	\setlength{\itemsep}{0pt}
	\item[] Authentication
	\item[] Authorization
	\item[] Gateway
	\item[] JWT
	\item[] Microservice Architecture
	\item[] OAuth 2
	\item[] OpenID Connect
\end{itemize}

% --- Table of contents autogenerated ------------------------------------
\newpage
\tableofcontents
\thispagestyle{empty}

% --- Begin of Thesis ----------------------------------------------------
\mainmatter
\chapter{Introduction}
\label{chap:intro}

In recent years, microservice architectures (MSA) have become increasingly popular. Netflix, Spotify, Amazon and other well-known corporations have moved to MSA \cite{saboorContainerizedMicroservicesOrchestration2022} and many others have followed their lead \cite{MicroservicesUseOrganizations} or are planning to do so in the near future \cite{MicroservicesEnterprise2021}. However, besides the well-known advantages such as high flexibility for development, redeployment and scaling, a small code base in the single services and low dependency between them, the same features also bring disadvantages that can not be ignored, like the increased attack surface that follows logically from the large number of endpoints which is necessary for the services to communicate between each other \cite{dragoniMicroservicesYesterdayToday2017}.

The financial damage caused to companies by data breaches averaged US\$4.35 million in 2022 \cite{CostDataBreach2023}. The personal damage that can result for individuals is hardly measurable. Unsurprisingly, not only but also in the context of MSA, topics such as authentication and authorization are therefore high on the list of security issues \cite{OWASPTop10}. In many cases, the damage can at least be limited by not only introducing a general access control but also, for example, distinguishing between different roles so that even a user or system that is legitimate in principle cannot access areas that do not fall within their scope. One such approach, which is easy to implement, is role-based access control (RBAC) \cite{computersecuritydivisionRoleBasedAccess2016}.

%In den vergangenen Jahren sind Microservice-Architekturen (MSA) zunehmend populärer geworden. Netflix, Spotify, Google, Amazon und andere bekannte Konzerne haben auf MSA umgestellt und viele andere sind ihrem Beispiel gefolgt !!! QUELLE!. Neben den bekannten Vorteilen wie Scalability, überschaubare Codebasis der einzelnen Services, geringe Abhängigkeit zwischen den Services und unabhängige Entwicklung, bringt dieser Architekturtyp allerdings auch Nachteile mit sich, u.a. im Bereich der Sicherheit. Der finanzielle Schaden, der für Companies durch Data breaches entsteht, lag 2022 bei durchschnittlich US\$4.35 millionen \cite{CostDataBreach2023}. Der persönliche Schaden, der für Individuen daraus entstehen kann, ist kaum messbar. Wenig überraschend stehen nicht nur aber auch im Kontext von MSA Themen wie Authentifizierung und Authorisierung ganz oben auf der Liste der Sicherheitsthemen \cite{OWASPTop10}. In vielen Fällen kann der Schaden zumindest eingegrenzt werden, indem nicht nur eine allgemeine Zugriffsbeschränkung eingeführt wird, sondern beispielsweise zwischen verschiedenen Rollen unterschieden wird, so dass auch ein prinzipiell legitimer User oder System keinen Zugriff auf Bereiche hat, die nicht in deren Bereich fallen. Ein solcher Zugang, der leicht zu implementieren ist, nennt sich role-based access control (RBAC) \cite{computersecuritydivisionRoleBasedAccess2016}.

OAuth 2.0 (OAuth2) is the industry-standard protocol for authorization \cite{OAuthOAuth} and also widely used in in MSA \cite{billawaSoKSecurityMicroservice2022}. It has been developed for secure third-party access to a resource on a user's or another sytem's behalf, but can also be used to authorize another service of the same system to access a resource, which makes it almost ideal for MSA. OpenID Connect is a layer on top of the OAuth2 protocol which deals with authentication, while OAuth2 only handles authorization.

OAuth2 is defined in RFC 6749 \cite{hardtOAuthAuthorizationFramework2012} and 6750 \cite{jonesOAuthAuthorizationFramework2012}. However, there is a number of other relevant documents associated with OAuth2 that have been added over the years. It can be a challenge for developers to keep track, make sure to meet all the requirements for OAuth2 and also take into account current best practices \cite{pareckiItTimeOAuth2019}. The long-awaited specification for OAuth 2.1 has been released as Internet-Draft in the attempt to consolidate OAuth 2.0 and it's extensions, which should improve this situation \cite{hardtOAuthAuthorizationFramework2023}.

%OAuth2 ist in RFC 6749 \cite{hardtOAuthAuthorizationFramework2012} und 6750 \cite{jonesOAuthAuthorizationFramework2012} definiert ist. Allerdings ist mit OAuth2 eine hohe Anzahl an weiteren Dokumenten verknüpft, die im Lauf der Jahre dazugekommen sind. Es kann für Developer eine Herausforderung darstellen, den Überblick zu behalten und darauf zu achten, alle Anforderungen für OAuth2 zu erfüllen und auch aktuelle Best Practice Vorgaben zu berücksichtigen \cite{pareckiItTimeOAuth2019}. Seit kurzem gibt es die langersehnte Specification für OAuth 2.1, die diese Situation verbessern soll \cite{hardtOAuthAuthorizationFramework2023}.

Spring Boot is a open source framework for Java that builds on the Spring Framework. It is widely used and often listed as the top framework for the development of microservices \cite{Slant13Best2023}, \cite{dhadukMicroservicesFrameworksScalable2022}, for reasons like fast deployment, embedded servers, dependency management, auto-configuration, code minimization and extensions that make it easy to build common patterns for distributed systems \cite{MajorReasonsChoose2023}, \cite{dinhtuanDevelopmentFrameworksMicroservicebased2022}. One component of the Framework is Spring Security, which offers extensive support for OAuth2. The out-of-the-box auto-configuration of Spring Boot helps to implement OAuth2 with very little code, but some manual configuration is still necessary at this level.

Keycloak is an identity and access management (IAM) platform which supports OIDC and RBAC. Like Spring Boot, Keycloak is free to use and open source. During the last years, the Keycloak Adapter for Spring Boot made it easy to integrate Keycloak with Spring Boot applications. However, this adapter is now deprecated and not supported anymore by Spring Boot 3 and more knowledge of Spring Security is required for the same tasks \cite{DeprecationKeycloakAdapters}, \cite{sandeepaUsingKeycloakSpring2023}. It does not help that the Keycloak documentation is not yet entirely up-to-date at this point and still mentions the use of the adapter. The same goes for most of the tutorials that can be found on the web.

From these initial conditions, the first research question arises as to how authorization and authentication according to OAuth2 and OIDC can be implemented in a MSA with Spring Boot 3 and Keycloak as the authorization server (AZ) and OIDC provider (OP) without the use of the deprecated adapter. For this purpose, the \textit{Teapot}, a small MSA prototype with the functionality of a virtual tea kitchen, has been developed as a proof of concept (PoC), with user authentication and role-based authorization. The resulting Spring Boot applications and the configuration of the Keycloak server have been analyzed in detail for compliance with the OAuth2 and OIDC specifications with the help of the Wireshark network protocol analyzer\footnote{https://www.wireshark.org/}, the Postman API platform\footnote{https://www.postman.com/} and \texttt{jwt.io/} for decoding access and id tokens.

OAuth2 defines among others the role of the resource owner, the resource server and the client. In a traditional client-server architecture, there is no question about the interpretation of these roles. The client is usually interpreted as equal to the browser-based or native frontend application, but in a system like MSA, where more components than only one client and one server are involved, the client in the sense of the OAuth2 role does not necessarily need to be the component closest to the resource owner, which can be another system or a human user, who wants the client to access a resource on their behalf. Instead, the client can also exist within the backend. This comes with several advantages. First of all, the OAuth access tokens are never sent to the browser and the client can be considered as confidential because it is able to hold it's own secret client credentials to authenticate with the AS \cite{pareckiOAuthBrowserBasedApps2023}. In this thesis, the term \textit{client} refers always to the OAuth2 role. The Teapot prototype was implemented in this manner, with both the resource server and the client in the backend, leaving a frontend application out of scope. However, since the gateway can be a possible bottle-neck in a distributed system, it is important to consider the perfomance implications of a gateway that performs the tasks of a client as opposed to those of a resource server. Therefore, this thesis also comprises a performance comparison between these two patterns. For this purpose, the Teapot system was recreated in two simplified versions that differ only in this detail at the gateway level from each other and load testing was conducted with Apache JMeter\footnote{https://jmeter.apache.org/}.

This thesis is structured as follows: the next chapter after this introduction (\ref{chap:relwork}) describes other publications which are relevant for this research. Chapter \ref{chap:background} gives an introduction into background and terminology and describes the most important features of MSA, Authentication and Authorization, RBAC, OAuth2 and OIDC. The implementation of the Teapot MSA prototype and the setup for load testing with JMeter is described in chapter \ref{chap:implementation}. Chapter \ref{chap:results} presents the analysis of the resulting implementation and it's compliance with the OAuth2/OIDC specifications, as well as the comparison between load testing results of the different gateway roles and conclusions are drawn in chapter \ref{chap:conclusion}.

%Forschungsfrage 1: OAuth2/OIDC in MSA mit Spring Boot und Keycloak - speziell interessant ohne den Keycloak adapter
%Dabei ergibt sich Forschungsfrage zwei: Client muss nicht unbedingt das Frontend sein, kann auch in Gateway implementiert werden. Zu welchen Performanceunterschieden führt das?

%Methodik: qualitativ und quantitativ
%Conclusion: falsche access tokens werden abgewiesen, aber es sollte gecheckt werden, welche vulnerabilities immer noch exisiteren, die es ermöglichen, als attacker einen gültigen access token zu erhalten.
%Alles hängt an der sicherheit vom session cookie. evt. keine so gute idee? andererseits, wenn ein session cookie gestohlen werden kann, kann auch ein access token gestohlen werden. session cookie security...

%Zur Implementierung anmerken, dass ses


%Struktur der vorliegenden BA.

%The second part of the investigation was a comparison between different positions of the client in the MSA architecture. In the terminology of OAuth2, \textit{client} does not necessarily mean the frontend application, but simply any application that gets access to the resource server on the user's behalf. W

%!!! Einleitung allgemein, Forschungsfragen:

%Die Rolle des Gateways für Authentifizierung und Autorisierung mit Oauth2 und OpenID Connect in Microservice-basierten Architekturen. Das Gateway kann sowohl als OAuth2-Client, als auch als Resource Server implementiert werden. Im ersten Fall muss das Gateway als Client einen Access Token vom Authorization Server beantragen und diesen an den Resource Server, also einen dahinter liegenden Service weiterschicken. Wenn das Gateway selbst als Resource Server implementiert ist, muss das Frontend als Client fungieren und den Access Token beschaffen.

%relevanz: hier erklären, dass die section authn+authz die relevanz deutlich macht. häh?

\chapter{Related Work}
\label{chap:relwork}

%Nehme et al. \cite{nehmeSecuringMicroservices2019} -> eher in Intro

Some research papers have been published about securing MSA with OAuth2 and Spring Security. The first to mention is the work of Nguyen \& Baker \cite{nguyenApplyingSpringSecurity2019}. They present a PoC of an MSA Inventory Management System on which they have conducted security tests to examine possible vulnerabilities. Other than in the present research, they do not use Keycloak, but implement their own Authorization Server with Spring Security instead. While in the present research the functionality and compliance with specifications is tested by sending valid and invalid tokens with postman and analyzing Wireshark captures, they conduct Cross-Site Request Forgery (CSRF), Cross-Site Scripting (XXS) and Brute Force attacks to test the efficiency of their implementation. Their architecture does not include an API gateway, the client web application can communicate directly with the resource server. Also different than the present research, they do not compare different implementations.

Chatterjee \& Prinz \cite{chatterjeeApplyingSpringSecurity2022} have developed an electronic health coaching (eCoach) prototype system, secured with Spring Security and Keycloak. In their extensive case study they also mention the use of the KeycloakWebSecurityConfigurerAdapter which was could not be used in the implementation presented in this thesis because of it's deprecation with Spring Boot 3 (see chaper/section ??? \ref{chap:intro}). Similar to this thesis, they have also used Wireshark for network traffic analysis and Postman for manual testing of API endpoints. They have also used Apache JMeter, but with the aim to test scalability of their implementation and not for comparison of different implementations.

Florén \cite{florenImplementationAnalysisAuthentication2021} has written a Master's thesis about the comparison between different MSA design patterns for authentication and authorization flows, an authorization flow inspired by OAuth2 with JSON Web Tokens (JWT). His work is focused on performance, which has also been tested with Jmeter. It is not clear to what extend the implementation follows the OAuth2 specifications! He found that with increased security (more security checks within the system) come longer response times, but only for high amounts of users. The services themselves were created with Spring Boot, while Express.js was used for the gateways. All compared patterns have in common that authentication and authorization is never implemented in the services themselves, but are always handled by a varying number of gateways, which are the only ones comunicating with the AZ. This thesis on the other hand follows a different approach, following the conclusion of ... !!! Quelle einfügen, that security requirements demand a certain negotiation of the definition of loosely coupled services.  % auch discovery service wäre dann nicht möglich...
%Außerdem kein striktes OAuth2?

While the more common approach in MSA seems to be that the gateway validates access tokens sent by a client outside of the MSA, thus acting as a resource server, there seems to be little or no academic research about the implications of the MSA gateway in the role of the OAuth2 client instead of the frontend application. However, a similar approach has been described recently as a possible pattern for browser-based or native applications in combination with OAuth2/OIDC by Parecki \& Waite \cite{pareckiOAuthBrowserBasedApps2023}. In this Best Current Practice (BCP) Internet-Draft, they use the term \textit{Backend For Frontend (BFF) Proxy} for a server which serves JavaScript code to the browser and is also able to act as a confidential client.  Although the document does not focus specifically on MSA and therefore does not assume that a gateway already exists in the architecture, from this point of view however, the idea to implement OAuth2 client functionality in the MSA gateway does not seem too far-stretched and has also been suggested by developers in blog posts \cite{BackendFrontendAuthentication}, \cite{AuthenticationPatternsBest}. This is what was implemented for the present research. In contrast to the model described by Parecki \& Waite, no frontend-application is served by the gateway, because the frontend is considered out of scope for this thesis and it is left open on purpose wheather there is an external frontend or wheather it can be loaded by the browser via the gateway itself. This is also the reason why the term BFF is not used in this thesis. According to Newman \cite{SamNewmanBackends}, authentication or authorization functionality alone is not sufficient to consider the gateway a BFF.

%RBAC: Triartono et al...

%Referenzierung im paper? sonst noch was allgemeines zu abgrenzung und gemeinsamkeiten

%eher weglassen: Alkhodary MA - BFF - more responsability, JMeter aber auch nicht client im BFF

%+Keine der genannten Quellen gibt einblick in den source code
%Erwähnen, dass ich nix akademisches über Gateway als client gefunden hab?

%!!!
% Auch Microservices Security in Action oder Spring Security in Action? Papers über Keycloak?

\chapter{Background and Terminology}
\label{chap:background}

\section{Microservice Architecture (MSA)}
\label{sec:msa-mon}

The first definition for microservices came from Lewis and Fowler in a blog post from 2014 \cite{lewisMicroservices2014}. They describe MSA in comparison to the traditional monolithic server architecture: while a monolith combines all necessary functionality in one piece of software, a MSA is a composition of loosely coupled, separate applications, each with their own domain-logic, running their own process. Figure \ref{fig:msa} illustrates this difference between MSA and monolithic architecture (MA). 

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/microservices-monolith.png}
	\caption{Monolithic architecture vs. microservice-based architecture according to \cite{lewis_microservices_2014}, \cite{rauchAuthxmicroservicesurauchPdf2023}.}
	\label{fig:msa}
\end{figure}

Inside a monolithic server the components communicate within the same process, via method invocation or function call. Microservices on the other hand communicate with each other via a simple protocol, often HTTP with RESTful API endpoints, or leightweight messaging such as RabbitMQ \cite{lewisMicroservices2014}. Of course also monoliths have endpoints and can use RESTful communication, but those endpoints will only be exposed to the outside of the monolith and are not used for internal communication. This difference is important as it has implications for MSA security, as will be explained in section \ref{sub:auth-msa}.

What makes the characteristic of microservices being only loosely coupled so important are the advantages that it brings under certain circumstances. These advantages are, according to Dragoni et al.  \cite{dragoniMicroservicesYesterdayToday2017}:
\begin{itemize}
\item Small code base: the separation into loosely coupled components makes for a small code base within each service, which makes it easier to build and to debug with a shorter down-time
\item Independent maintentaince and redeployment of single services
\item flexible scaling: smaller parts of the system can be duplicated where and when they are needed
\item Flexible development: services can be built using different languages and frameworks, following the circumstances posed by the domain or by the teams capabilities and preferences, as long as it does not affect the communication between them
\end{itemize}

MSA is also very suitable for containerization and the upcoming of technologies like Docker and Kubernetes has further contributed to the deployment flexibility of microservices \cite{pahlContainerizationPaaSCloud2015}.

However, MSA is not the best solution in each and every situation. MSA can be a good idea for companies who want to benefit from the scaling flexibility and potentially minimized cost associated to scaling offered by MSA, minimize down-time when availability of all or certain parts of the product is especially crucial for their bussiness, improve development speed by adding more developers, or integrate new technology into their system \cite{newmanMonolithMicroservices}. However, there are trade-offs between those factors and other circumstances which make MSA not the ideal choice, for example when the domain is unclear or likely to change, when the software product will be installed and maintained by the customer itself and not by the development team or for a small startup that is still experimenting in a new field, before it finds a successful approach \cite{newmanMonolithMicroservices}.

One reason to be cautios when adopting a MSA approach is that MSA poses specific security challenges. These will be addressed in section \ref{sub:auth-msa}.

\section{Authentication and Authorization}
\label{sec:authx}

Authentication and Authorization are related concepts and often they only appear linked to each other, which might be the reason why the distinction between the two is not always so clear. This section gives a short introduction and explains how they are different from each other.

\subsection{Authentication}
\label{sub:authentication}
Authentication deals with the question of identity. Often it is crucial to know the identity of a user in order to decide if the user is allowed to access a specific resource. If this is the case it might also be important to know later, that this person has accessed the resource, for example if someone has misused their right to access the resource for another than the allowed purpose, like stolen or manipulated data. The process of authentication involves the information who someone is, for example during a login process this can be a user id, and also the prove that this information is correct. This prove can be in the form of something only this person knows, like a secret password, or something only this person has, like a code that can be sent to this persons phone number, or some unique attribute of this person, like biometric data \cite[pp. ~59ff]{siriwardenaAdvancedAPISecurity2020}. A combination of those is multifactor authentication and increases the level of security. Not only human persons need authentication, but also systems can posess a kind of id that identifies them and a prove in the form of a secret code, a token or a certificate. In any case, there must be a database that can be consulted to verify that this prove is valid, otherwise it would be of no value, but it is not necessary for the system that controls access to a resource to possess the database itself, it can delegate the whole business of user authentication to a different entity that functions as an identity provider (IP).

\subsection{Authorization}
\label{sub:authorization}
Authorization on the other hand is about permissions. Naturally, in order to decide if someone should be authorized to access a resource, this will often require knowing who this person is. But in theory this is not necessarily the case by definition. A person might earn the right to access a resource regardless of who they are, or they might be authorized because of certain attributes, as it is the case for example with many public toilets that are open only for certain genders. It doesn't matter at all what a person's name is or when they were born, but they are allowed to access the toilet resource only if they appear to have the correct gender attribute. But in other more complex systems, especially where security is a priority, authentication is crucial in the combination with authorization. Roles or attributes of persons or other systems are determined based on their identity and in a second step it can be verified if the role or attribute authorizes them to access the resource. A person with the intention to access a resource might be able to prove that they are who they say they are, but they might still not be authorized to access the resource. This too requires the consulting of data to know who is allowed to do what.

\subsection{The role of authentication and authorization in MSA}
\label{sub:auth-msa}

With the characteristics of MSA, authentication and authorization play an even more important role than ever, although Service oriented Architecture (SOA) and distributed systems already point in the same direction \cite{dragoniMicroservicesYesterdayToday2017}. The Open Web Application Security Project (OWASP) lists again broken authentication and broken authorization on top of the Top 10 API Security Risks for 2023 \cite{OWASPTop10}. The main security challenges related to MSA were identified by Dragoni et al. to be a large surface attack area, network complexity, trust and heterogeneity \cite{dragoniMicroservicesYesterdayToday2017}. While heterogeneity and especially trust might not always be present to the same degree in all MSA systems, the large surface attack area due to the increased number of endpoints and network complexity are inherent features in any MSA system compared to a monolithic architecture. 

From the external perspective the experience might not be different when communicating with the MSA system via an API gateway, which hides the underlying complexity of the system. There are only a couple of relevant entry points \cite{shmelevaHowMicroservicesAre}. But inside the system, the situation is very different: Because each single service must expose at least one endpoint to be of use in the MSA system, the number of endpoints that have to be protected is at least equal to the number of services. Compared to a monolithic system, this makes the implementation and management of authentication and authorization in a MSA more complex.

Authors have pointed out the necessity (and also the increasing adoption in the industry) of a zero trust policy for MSA, which means that each microservice considers all other microservices or actors as potentially hostile and therefore no service should trust any incoming request without verifying it's integrity, regardless of who the sender might be \cite{luSurveyMicroservicesTrust2023}, \cite{shmelevaHowMicroservicesAre}. This approach is important for the mitigation of the confused deputy attack, where a corrupted microservice interacts with other microservices who have no idea that it acts on the attackers behalf \cite{nehmeFineGrainedAccessControl2019}.

\subsection{Role-Based Access Control (RBAC)}

RBAC was introduced by Ferraiolo and Kuhn in 1992 \cite{ferraioloRoleBasedAccessControls1992}. It is an approach to managing access to resources by differentiating between kinds of users. Users are assigned a role that gives them the minimum authorization necessary for them to fulfill their tasks within an organization. For example, not all users need the same access rights as an administrator or manager. RBAC therefore follows the principle of least privilege (PoLP).

SESSION etc...


%triartonoImplementationRoleBasedAccess2019 implementieren RBAC Oauth2 in MSA -> related work? keine prio!
%Pasomsup & Limpiyakorn nicht 

\section{OAuth 2 and OpenID Connect}
\label{sec:oauth-oidc}

To begin with, OAuth 2 (OAuth2) is a framework or open protocol for authorization only. OAuth2 is considered the inofficial standard for securing the access to APIs \cite[p. ~81]{siriwardenaAdvancedAPISecurity2020}, \cite{barbettiniOAuthOpenIDConnect2018}. It does not deal with authentication, but authorization only. It has been described in Request for Comments (RFC) 6749 \cite{hardtOAuthAuthorizationFramework2012} and RFC 6750 \cite{jonesOAuthAuthorizationFramework2012}, followed by a long tail of further specifications \cite{dennissOAuthDeviceAuthorization2019}, \cite{jonesOAuthTokenExchange2020}, \cite{campbellResourceIndicatorsOAuth2020}, \cite{sakimuraOAuthAuthorizationFramework2021}, Security Considerations \cite{lodderstedtOAuthThreatModel2013}, \cite{sakimuraProofKeyCode2015} and a series of Security Best Current Practice Internet drafts \cite{2023}\footnote{This is not a comprehensive list.}. The original specifications from 2012 have been updated by RFC 8252, "OAuth 2.0 for Native Apps" \cite{dennissOAuthNativeApps2017} and by "OAuth 2.0 for Browser-Based Apps" \cite{pareckiOAuthBrowserBasedApps}. Since this is not even a comprehensive list, it is understandable that the new specification for OAuth 2.1 \cite{hardtOAuthAuthorizationFramework2023}, which has been published just recently, has been long awaited by some. It replaces RFC 6749 and 6750.

Because OAuth2 to is not intended to be used for authentication, OpenID connect (OIDC)\cite{sakimuraOpenIDConnectCore2014}  was created as a seperate layer for this purpose, in addition to OAuth2 in 2014. Therefore it should be clear that these two are not alternative concepts to choose from, but when securing services, both should be used.
% mehr details dazu in section xy?

\subsection{OAuth2}
\label{sub:oauth2}
The motivation for the creation of OAuth2 was to enable a client application to access a resource on a server on behalf of the owner of that resource without the need to pass on the resource owners credentials to this client for authentication \cite{hardtOAuthAuthorizationFramework2023}. Third-party access to resources is a very common practice, the standard example is an application that needs access to a user's facebook timeline \cite[p. ~81]{siriwardenaAdvancedAPISecurity2020}, but it may as well be a different resource like pictures or a person's calendar. Sharing a password with a third-party application is undesireable for several reasons \cite{hardtOAuthAuthorizationFramework2023}: Passwords are inherently weak, especially in combination with human users, who tend to reuse passwords on different unrelated systems and servers would have to implement support for password authentication. Third-party applications would store these passwords, typically in clear-text. By authenticating with the server as the user, the third party application would have access to all of the user's data with the same permissions as the user themselve. The only way to revoke access for such an application would be to change the password, which would naturally exclude all other third-party applications as well.

OAuth2 separates the role of the \textit{client} (the third-party application) from the \textit{resource owner} (the end user who allows access to a resource to the client), so that the client is not required anymore to pretend to be the user by using the user's credentials when communicating with the \textit{resource server} (the server holding the resource). Instead of a password the client sends an \textit{access token} with every request to the resource server. This access token has a limited lifespan and other attributes that allow to control the extend to which the client can access the resources on that server. This access token is issued to the client by an \textit{authorization server} after the user has given consent for the client to access the resource. Following the principle of separation of concerns, the authorization server is also the only one dealing with authentication of the user \texttt{hardtOAuthAuthorizationFramework2023}.

The explicit consent of the resource owner for the client to access the resource is called \texttt{authorization grant}. The client can use this grant to obtain the access token from the authorization server. There are several different authentication grant flows defined for OAuth2. The preferred grant type for most use cases is the \textit{Authorization Code} grant type\footnote{Before OAuth 2.1 there was also the \textit{Implicit} grant and the \textit{Resource Owner Password Credentials} grant, but they are not considered secure anymore. Their use has already been excluded by OAuth 2.0 Securit Best Practice documents\cite{lodderstedtOAuthSecurityBest2023a} and they are completely omitted in the new specification \texttt{hardtOAuthAuthorizationFramework2023} (See also \cite{rauchAuthxmicroservicesurauchPdf2023}).} Other grant types are the \textit{Refresh Token} grant and the \texttt{Client Credentials} grant. With the \textit{Authorization Code} grant the authorization server issues first only a code to the user agent together with the redirect url. After the authentication, the user is sent back to the client by the authorization server with this redirect url and the authorization code. The client application can now send the code to a different endpoint at the authorization server, the \texttt{token endpoint}, and exchange it for an access token. In this way the access token is transmitted only via backchannel communication, which makes it harder for attackers to intercept the token. There are also additional measurements to make the code exchange more secure, like the \texttt{state} parameter and \textit{Proof Key for Code Exchange} (PKCE). When the client redirects the user agent to the authorization server (this is called the authorization request), it must create a code challenge and add it to the request, unless it is a confidential client and the OIDC \texttt{nonce} value is used. Other required parameters are the \texttt{response\_type} (\texttt{code} for the \texttt{authorization code grant}) and the \texttt{client\_id} \cite{hardtOAuthAuthorizationFramework2023}. Figure \ref{fig:auth-code-grant} shows the steps involved between the different roles during the authorization code grant flow.

%Stimmt nicht: OAuth 2.1 does not require...: It is also important to know that clients have to be registered with the authorization server in order to be able to authenticate later when requesting an access token\texttt{hardtOAuthAuthorizationFramework2023}.
% Hier altes oder neues diagram für den abstrahierten OAuth2 flow, falls noch platz ist
\begin{figure}
\includegraphics[width=\textwidth]{images/auth-code-grant}
\caption{Steps of the authorization code grant in the interaction between all roles as described in \cite{hardtOAuthAuthorizationFramework2023}}
\label{fig:auth-code-grant}
\end{figure}

\subsection{The Access Token}
\label{sec:accesstoken}

The OAuth2 specification does not define the nature of the access token. Although it can be any arbitrary string that has no further encoded information (this would be a reference token), it is considered best practice to use self-contained tokens like JSON Web Tokens (JWT), because the resource server itself can validate them and determine if the authorization is sufficient for the request, without having to build up a connection to the authorization server each time or maintaining a token database \cite{hardtOAuthAuthorizationFramework2023}. Specifically, in the context of distributed systems like MSA, the use of JWT as access tokens is advisable. One reason is that they can be validated locally and not every single request to the system has to be validated first with the authorization server, which could result in performance loss \cite{yang_research_2020}. The drawback of local token validation is that if a token has been revoked, the validating service doesn't know this and will give the client with the token access until it expires \cite{jacksonMicroserviceAuthenticationAuthorization2019}.  The use of JWTs as access tokens for OAuth2 is specified in RFC 9086 \cite{bertocciJSONWebToken2021}.

%. They also have the advantage that they usually expire after a while. The drawback of local token validation is that if a token has been revoked, the validating service doesn't know this and will give the client with the token access until it expires [!!! notfalls Nic Jackson].

The client requests access tokens from the \texttt{token endpoint} at the authorization server with a POST request including at least the \texttt{client\_id} and the \texttt{grant\_type} \cite{hardtOAuthAuthorizationFramework2023}. Confidential clients, wich are capable of maintaining secret information will also include a form of authentication, symmetric (password) or asymmetric (a signed JWT or mTLS). It is also possible for the client to include a \texttt{scope} request parameter. This is necessary for example when using OIDC (see section \ref{sub:oidc}).%hier nocheinmal quelle?

The response from the authorization server, if the authorization request was valid, includes several parameters \cite{hardtOAuthAuthorizationFramework2023}: the freshly issued access token  for the client and \texttt{token\_type}, which is usually \texttt{"Bearer"}, as well as a \texttt{scope} parameter are required by the specification. The authorization server can decide if the scope specified in the request will be included. Further recommended is \texttt{expires\_in}. A refresh token can also be included in the response, depending on the type of client and other factors. Figure \ref{fig:token-response-oauth} shows a token response from Keycloak. The lifespan for the access token is configured to be three minutes and because the authenticated user has only read privilege, the scope \texttt{tea\_read} is included.

\begin{figure}
\includegraphics[width=\textwidth]{images/token-response-oauth}
\caption{Token response from the Keycloak server in Postman}
\label{fig:token-response-oauth}
\end{figure}

A JWT is base64-encoded and is made of three parts, the header, payload and the signature. Any JWT that is used as access token for OAuth2 must be signed, as specified in RFC 9068, to ensure it's integrity, preferably with asymmetric cryptography \cite{bertocciJSONWebToken2021}. The header contains the \texttt{alg} parameter indicating the signing algorithm, which has to include \texttt{RS256}, and the \texttt{typ} parameter, which has to be \texttt{at+jwt} (recommended) or \texttt{application/at+jwt}. The payload contains the claims set where the following claims are mandatory for Oauth2 access tokens \cite{bertocciJSONWebToken2021}:

\begin{itemize}
\item \texttt{iss}: Issuer. Indicates the issuer of the access token.
\item \texttt{exp}: Expiration time. The life span of the access token before it becomes unvalid.
\item \texttt{aud}: Audience. Indicates the resource for which the access token should be used.
\item \texttt{sub}: Subject. The subject of the access token is an id that belongs to the resource owner, if involved, otherwise the client.
\item \texttt{client\_id}: Client ID. Identifier for the client requesting the access token.
\item \texttt{iat}: Issued at. The time when the access token was issued.
\item \texttt{jti}: JWT ID. Unique identifier for the JWT.
\end{itemize}

An example for a decoded access token is shown in figure \ref{fig:keycloak-access-token-aud-roles}, although it does not conform entirely to the specifications, as the  \texttt{typ} header parameter contains \texttt{JWT} instead of the required \texttt{at+jwt} value. The client id is instead present with the \texttt{azp} claim.

When validating the access token, the resource server checks the signature, lifespan, scope and possibly other authorization parameters for the specific resource \cite{hardtOAuthAuthorizationFramework2023}. The signing keys can be requested by the resource server from the AS in a JSON Web Key Set (JWKS), which the AS can offer as a part of it's metadata the the well-known metadata endpoint \cite{jonesOAuthAuthorizationServer2018}.
%gibts keine specification drüber, wie der rs an den key bzw jwks kommt?

\subsection{OpenID Connect (OIDC)}
\label{sub:oidc}

When it comes to authentication of end-users, OIDC \cite{sakimuraOpenIDConnectCore2014} gives the answers that were left out bei OAuth2. The content of an OAuth2 access token is of no interest for the client. When the client needs information about a user's identity, it can request an additional \textit{ID token} by adding \texttt{openid} to the \texttt{scope} parameter in the authorization request, which thus becomes a authentication request. Also the \texttt{redirect\_uri} parameter is now required. Among other optional parameters there is the \texttt{nonce} parameter to mention. It is a string value, used to protect against replay attacks, that should be unguessable and it represents session state between the client session and the ID token. The ID token will then be issued by the authorization server which is now called OIDC provider (OP), together with the access token and delivered as a part of the token response \cite{sakimuraOpenIDConnectCore2014}.
The ID token itself is a signed JWT which contains the \texttt{iss, sub, aud, exp} and \texttt{iat} claims as a requirement. When using the authorization code flow, also the \texttt{at\_hash} claim is required. It contians a the  base64 encoded left most half of the corresponding access token's hash. The \texttt{nonce} claim is reqired if it was present in the authentication request, with the same value, which will be verified by the client. Other optional claims are \texttt{amr} (authentication method references), \texttt{acr} (authentication context class reference) and \texttt{azp} (authorized party), containing the client id of the authorized client. The ID token itself does not contain personal user information. Instead there is a separate OAuth2 protected \texttt{/userinfo} endpoint where the client can request additional metadata about the user with the access token \cite{sakimuraOpenIDConnectCore2014}.

!!! Verweise auf Listings oder Screenshots, die später eingefügt werden als beispiel

%was brauchts von dem Teil noch?
%Today, when reading about OAuth2, the warning that OAuth2 should not be used for authentication is hard to overlook. Still, authentication is an important component in order to secure a system and OAuth2 can be used \textit{within} an authentication scheme \cite{richer_end_nodate}. With OAuth2, the resource owner will authenticate to the authorization server and also the client has to authenticate to the authorization server in many cases, but it is not the concern of OAuth2 \textit{how} the authentication is done \cite{richer_end_nodate}. In this context it is useful to understand that for the client the access token has no meaning and will just be passed on to the resource server for validation. The client does not learn anything about the user and the fact that an access token was issued should not be misunderstood as a proof that the end-user was correctly authenticated \cite{richer_end_nodate}. When information about the user is needed, OAuth2 is therefore not sufficient to cover authentication, even if this has not been and might still not be an unusual practice \cite{barbettini_oauth_2018}, \cite{jackson_microservice_2019}. The problems and pitfalls associated with the use of OAuth2 for authentication purposes are discussed more in detail in \cite{richer_end_nodate}. Instead, OpenID Connect (OIDC) is a layer on top of the OAuth2 specification and has been developed exactly for this purpose.

%more security aspects: tls - ist MUST in specs, csrf state parameter, nonce (auch in oauth?)



%OpenID Connect 1.0 (OIDC) is an open protocol defined as a layer on top of OAuth2 by the OpenID Foundation \cite{sakimura_openid_2014} in 2014. Often there is a need for clients to be able to identify end-users, and OAuth2 does not fulfil this purpose, because it is not intended to be used for authentication. OIDC was developed to close this gap \cite{richer_end_nodate}.

%An OIDC flow is very similar to the OAuth2 flow, with a small, but significant difference: in addition to the access token, the authorization server, which is also responsible for handling authentication of the end-user, thus now being an OIDC provider or authentication server, issues also an ID token \cite{sakimura_openid_2014}, \cite{richer_end_nodate}.
%The client can also send the access token to the UserInfo Endpoint (at the OIDC provider), which will return a defined set of additional standard claims about the user \cite{sakimura_openid_2014}.
%---Zeichnung für OIDC flow hier---\\
%The OIDC flow consists of the following steps \cite{sakimura_openid_2014}:
%\begin{enumerate}
%\item Authentication request from the client to the OIDC provider
%\item Authentication of the end-user at the OIDC provider + obtaining authorization
%\item ID token (and usually access token) issued by OIDC provider to client
%\item UserInfo request with access token from client to UserInfo endpoint
%\item UserInfo response from UserInfo endpoint to client
%\end{enumerate}

%The OIDC specification provides three specific authentication flows \cite{sakimura_openid_2014}:
%\begin{itemize}
%%\item The \textit{authorization code flow}, similar to the process described for the authorization code grant in section \ref{sec:oauthgrants}, but an ID token is issued to the client together with the access token.
%%\item The \textit{implicit flow}, again similar to the OAuth2 implicit grant. The OIDC provider redirects the end-user to the client, together with the ID token and the access token.
%%\item The \textit{hybrid flow} combines characteristics from both other flows. Clients receive always an authorization code and additionally the access token or the ID token. The other token can be exchanged for the authorization code.
%\end{itemize}

%As per the OAuth2 specification, an access token is opaque to the client \cite{hardt_oauth_2012}. In order to maintain this requirement, the ID token carrying information for user authentication is a separate token, issued alongside the access token \cite{sakimura_openid_2014}. The ID token is a JWT, containing claims similar to the OAuth2 access token, such as \texttt{iss, aud, exp, iat} (see section \ref{sec:oauth}, but also the \texttt{sub} claim, to uniquely identify the subject (end-user) with the client, \texttt{nonce}, which is used to prevent replay attacks and to associate the ID token with a client session, and other optional claims (\texttt{acr, amr, azp}). Other claims are possible as well, however, claims must be understood or be ignored otherwise. An example for an ID token is given in listing \ref{lst:idtoken}, where also the \texttt{auth\_time} claim is used, denoting the time when the user has authenticated. An OIDC authentication request is an OAuth2 authorization request where the \texttt{scope} parameter must be present with \texttt{open\_id} as a value. Other values for \texttt{open\_id} can be present as well \cite{sakimura_openid_2014}.\\

%section 3.1.2.1.
%\begin{lstlisting}[frame=lines, caption=Example for an ID token according to \cite{sakimura_openid_2014}, captionpos=b, label = lst:idtoken, language=c, showstringspaces=false]
% {
%   "iss": "https://server.ularauch.net",
%   "sub": "24400320",
%   "aud": "s6BhdRkqt3",
%   "nonce": "n-0S6_WzA2Mj",
%   "exp": 1311281970,
%   "iat": 1311280970,
%   "auth_time": 1311280969,
%   "acr": "urn:mace:incommon:iap:silver"
%  }
%\end{lstlisting}

%section 5.3.2
%\begin{lstlisting}[frame=lines, caption=UserInfo Response example according to \cite{sakimura_openid_2014}, captionpos=b, label = lst:userinfo, language=c, showstringspaces=false]
%  HTTP/1.1 200 OK
%  Content-Type: application/json

%  {
%   "sub": "248289761001",
%   "name": "Ula Rauch",
%   "given_name": "Ursula",
%   "family_name": "Rauch",
%   "preferred_username": "ulala",
%   "email": "ursula.rauch@stud.fh-campuswien.ac.at",
%   "picture": "http://ularauch.net/ulala/ula.jpg"
%  }
%\end{lstlisting}


%Although the ID token appears to be very similar to an access token, there are some important differences to be pointed out \cite{parecki_oauth_nodate}:%https://oauth.net/id-tokens-vs-access-tokens/ - genaue seite angeben?
%\begin{itemize}
%\item The audience: ID tokens should only be sent to and read by the OAuth2 client. Consequently, ID tokens should never be sent to an API. Access tokens should be read only by the API (the resource server) it was meant for, but never by the client.
%\item The format: the format for access tokens is not specified, it can be a JWT, but it can also be an arbitrary string, while on the other hand an ID token is always a JWT.
%\end{itemize}

%OIDC also defines a protected resource at the OIDC provider, the UserInfo endpoint, where the client can request a set of standard claims with meta-data about the user in question in exchange for the access token \cite{sakimura_openid_2014}. An example for these claims is shown in listing \ref{lst:userinfo}. Also, like in the initial authentication request, the \texttt{scope} parameter must be present with the value \texttt{open\_id} in the request for userInfo claims \cite{sakimura_openid_2014}.

%Ende: betonen, dass das nicht obligatorisch ist? steht bei richer, aber kommt aus der oidc spec nicht so raus.

% Noch mehr OIDC:

%Why - pitfalls with using OAuth2: evt. auslassen, nur das wichtigste funktionale

%Important to not confuse it with OpenID, which is not just a short name of OpenID Connect, but rather the other way round, OpenID is independent of OAuth 2, while OpenID Connect is its extension 

%trennung zwischen access token und id token essentiell -> inhalt vom access token geht den client wenig an, dafür kann mit infos aus id token eine session gemacht werden \cite{ideskog_oauth_nodate} (bis eine bessere quelle kommt, spec lesen!)

\section{The positioning of the OAuth2 client in a MSA system - CHECKEN}
\label{sec:msa-oauth}
!!! nocheinmal anschaun. wo soll der abschnitt hin und was ist die intention? Titel?
%API gateway wurde evt. schon in MSA einführung erklärt
When bringing the two concepts of MSA and Oauth2 together, some decisions have to be made about the role of each service, which also depend on the overall architecture of the microservice system. Many different architectural patterns for MSA have been proposed and studied \cite{akbulutPerformanceAnalysisMicroservice2019}. One very common pattern is the API Gateway, which functions as entry point for requests coming from a browser, a mobile application or any other kind of frontend \cite{bazeniucInformationSecurityMicroservices2021}, so that the single backend services are not required anymore to be reachable from the outside. A very similar pattern is Backends for Frontends (BFF), where as many different gateway services are implemented as there are different frontend applications \cite{SamNewmanBackends}. The distinction between the two patterns seems to be fluent to a certain degree. Sometimes it is called a BFF when an API Gateway assumes the functionalities of an OAuth2 client \cite{SpringaddonsSamplesTutorials}, \cite{SamNewmanBackends}, however this does not seem to meet the full definition of a BFF.

The most simple implementation would probably be to implement only the gateway as OAuth2 resource server, but not the backend services, assuming that the gateway will deal with any unauthorized request. For this scenario there are other ways to secure the communication between services, like mutual Transport Layer Security (mTLS), supposedly the most popular option (see \cite[pp. ~137ff]{siriwardenaMicroservicesSecurityAction2020}. This means that the service holding a requested resource might not necessarily be a resource server in the sense of OAuth2. The Gateway will decide if the user should access a resource and it will forward the request only if the user can prove to have the necessary authorization (access token). However this comes with drawbacks, for example it does not meet the requirement of defense in depth, where access control happens on several layers and access control in one single point can become hard to manage with a more complex access policy and many roles involved \cite{barabanovAuthenticationAuthorizationMicroservicebased2020a}. For better security it is also possible to implement several resource servers in a series, which either renew the access token or hand down the original access token to the next downstream service after validation \cite[pp.~161ff]{siriwardenaMicroservicesSecurityAction2020}. This is similar to the chain of responsibility pattern \cite{akbulutPerformanceAnalysisMicroservice2019}. A simplified version of this concept has been implemented and tested for this thesis (see chapter \ref{chap:implementation}). In both cases however, the job position of a (registered) OAuth2 client is still vacant. There should be a service or application that is able to determine if the user has already authenticated, refer to the OP for authentication and obtain the access token on the user's behalf. This means that any possible frontend has to implement OIDC client functionality.

Another version, which can sometimes be found in OAuth2/OIDC MSA tutorials, relieves the frontend of this burden and implements the gateway directly with the functionality of an OAuth2 client. This variant was also implemented for this thesis and is described in detail in section \ref{chap:implementation}. The services beyond are resource servers, so that the communication between the API gateway and the next downstream service is secured via access tokens, while the gateway keeps a session for the communication with the frontend to know if the requesting user is authenticated.

Naturally, both variants, with the API gateway or the frontend application as the OAuth2 client bring advantages and disadvantages in different aspects, like system performance, code complextiy and further security considerations. In chapter \ref{chap:implementation}, not only the implementation of a prototype is described, but also the setup for a performance test in order to compare response times of both variants. The results of these tests are presented and discussed in chapter \ref{chap:results}.

\section{Methodology - WEGLASSEN WEIL IMPLEMENTATION?}
\label{sec:methodology}
%!!! Darf ich das so schreiben?
%The first research question, how OAuth2 authorization and authentication with OIDC are implemented in MSA using Spring Boot and the Spring Security Framework with a Keycloak server, was answered mainly by collecting and combining information from online tutorials and use them to implement a prototype as a proof of concept. The implementation is described in detail in chapter \ref{chap:implementation}. It should be noted that the aim was not to follow or develop a best practice model. For example in production TLS would be required on all connections, but was left out because the focus lies on authentication and authorization of users with OAuth2 and OIDC. Also mTLS was considered to be beyond the scope of this thesis and therefore left out. Correct authentication and authorization of end users was tested and examined using Postman\footnote{https://www.postman.com/} and Wireshark\footnote{https://www.wireshark.org/}.

%In the first version, the API gateway was implemented as OAuth2 client. In order to investigate the matter of the positioning of the OAuth2 client, the system was recreated in three versions, containing only the necessary features for a performance comparison between the API gateway as client, as resource server and a completely unsecured version to relate the outcome. Performance tests were carried out using Apache JMeter\footnote{https://jmeter.apache.org/}. Details about the setup are documented in section \ref{sec:loadtesting-jmeter}.

%Für Forschungsfrage 1: Follow Spring Boot Documentation and Tutorials -> implement the Teapot and test Authentication and Authorization functionality with Browser, Postman and Wireshark.
%Für Forschungsfrage 2: Implement a reduced version of the Teapot system in three different ways and perform load tests with jmeter. Compare response times.

\chapter{Implementation of the Teapot MSA application}
\label{chap:implementation}

!!! Einleitende worte?

%!!! Was noch?


%!!! hier nur abgelegt:
%	With the basic implementation of the prototype system (see section 4 Impl (reihenfolge tauschen?), 4 different versions were created: one with the Gateway as the OAuth2 client and with the Tea Service as a Resource Server, one where the Gateway and the Tea Service are both Resource Servers and one where only the Gateway is a Resource Server and the Tea Service remains unprotected. The initial intention was to implement MTLS between the Gateway and the Resource Server as recommended in [Siriwardena - Microservices Security in Action - Seite???]. This last version was later abandoned in favour of the focus on the difference of the client position in the system. Testing a difference between OAuth2 and MTLS lies outside the scope of this thesis.

\section{The Teapot - High level design}
\label{sec:high-level}
!!!
The project that was built for this thesis is a virtual tea kitchen, called "The Teapot". In the Teapot system the user can view a list of available types of tea and request a "cup" of the chosen tea. The MSA consists of the API Gateway, the Tea Service with a MongoDB database, which offers endpoints for creating or updating a type of tea, requesting the list of all available types, deleting tea and "making tea", where the user gets back a message containing the requested type of tea or just hot water, if the requested tea is not available. There is also a separate Milk Service and a Eureka Discovery Service where the Gateway and the other Services are registered. The gateway offers endpoints to the outside world and stands between the other services and the users. It routes requests requests to the Tea and Milk Service respectively, so that the user or any frontend doesn't have to communicate directly to the services beyond the gateway. A keycloak server is deployed for security, serving as OP and AS. The high-level architecture of the teapot is depicted in figure \ref{fig:original-teapot-architecture}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/original-teapot-high-level}
	\caption{High level diagram of the implemented services and their relation to each other}
	\label{fig:original-teapot-architecture}
\end{figure}

However, since there is a lot of functionality present that is not necessary for this research, the whole system was rebuilt in a even simpler version for the second part of the load testing in the second part of the investigation. It was reduced to the gateway and one additional service for the gateway to communicate with, and of course the keycloak server. The Gateway and the Tea Service offer "hello"-endpoints that were used in the beginning for debugging. These endpoints were used for load testing, as will be described in more detail in section \ref{sec:loadtesting-jmeter}. They return a simple string message and do not require the database. This means that the gateway has two relevant endpoints: \texttt{/helloauth}, which the gateway itself responds to immediately, and  \texttt{/hellotea/name}, which is routed from the gateway to the Tea Service. \texttt{name} can be any string and will be returned in the responding message.
The remaining, stripped-down system is represented by figure \ref{fig:teapot-architecture}.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/teapot-high-level}
	\caption{High level diagram of the implemented services and their relation to each other}
	\label{fig:teapot-architecture}
\end{figure}

In total, there are three versions of the reduced system: the first version where the Gateway acts as the OAuth2 client and the Tea Service serves as the resource server, the second version where both the Gateway and the Tea Service function as resource servers, and a third version with no security implementation at all. The second version would require the inclusion of a frontend application to incorporate OAuth2 client functionality.

With this implementation, the first request to a protected resource, when the gateway has not obtained an access token yet, can be depicted as in figure \ref{fig:oauth2-flow-seqd}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/oauth2-flow_sequence-diagram}
	\caption{Sequence diagram of the first request to a protected resource including a simplified auth code grant flow}
	\label{fig:oauth2-flow-seqd}
\end{figure}

The detailed authorization code grant flow is shown and explained in sections \ref{sub:oauth2} and \ref{sec:conformance}, therefore a simplified version is depicted in this diagram.

Any subsequent request, as long as the access token is valid, is much simpler. The gateway already has an access token and all it has to do is append this access token to the routed request as authorization header and forward it to the Tea Service. This scenario is also used for load testing, as will be explained in sections \ref{sec:loadtesting-jmeter} and \ref{sec:response-times}.

The second version does not implement a client at all. It is simply two resource servers in series. The gateway recieves an access token with the request, possibly from a frontend client, validates it and forwards it to the Tea Service, which again validates the access token 
In both versions, the Tea service, or the Tea service and the gateway respectively, must obtain the JSON Web Key Set (JWKS) from the Keycloak Server, so that they will be able to validate signature of the access token. This happens at the first request.
% detaillierte abbildungen sind hier evt. redundant... später weitermachen!

The third version is again a copy of the other two but the Keycloak Server is not needed in this case and the services do not care about authorization at all.

\section{Setup with Spring Boot and Keycloak}
\label{sec:setup-spring-boot}

\subsection{Spring and Spring Boot}

All Services in this project were developed using Spring Boot\footnote{https://spring.io/projects/spring-boot} Version 3.0. 
Spring Boot is created on top of the Spring framework, a widely used open source application framework for Java. Spring provides dependency injection and different modules, like Spring Security, Spring Test or Spring ORM (object-relational mapping), among others \cite{IntroductionSpringFramework}. Spring Boot was created in order to simplify the development of Spring-based applications by offering autoconfiguration and starter dependencies that bundle selections of libraries in one Maven or Gradle dependency \cite[pp.~4f]{wallsSpringBootAction2016}. This helps to reduce the need for the developer to write boilerplate code manually, which means that one big advantage when using Spring boot is the quick project setup. However, these configurations can be overridden or customized when needed, like it is the case for security configurations \cite[p.~50]{wallsSpringBootAction2016}, either programmatilally with Java or in many cases by adding configurations to the \texttt{applications.properties} or the \texttt{applications.yml} file \cite{CoreFeatures}. For the Teapot project the \texttt{yml} variant was used whenever possible because this way configurations are easier to write and read, and therefore they are less error-prone.

Spring Boot projects can be initialized and downloaded with the Spring Initializr\footnote{https://start.spring.io/} which is also available when creating a new Project in IntelliJ. All Maven dependencies that are needed for a project can be chosen during project creation with Spring Initializr, or they can be added later to the \texttt{pom.xml} file.

\subsection{The Keycloak Server}
\label{sub:keycloak}

Keycloak \cite{Keycloak} is an identity and access management (IAM) platform. It is open source and published under the Apache Licence 2.0\footnote{http://www.apache.org/licenses/LICENSE-2.0}. It supports OAuth2, OIDC and SAML. As an IAM, the Keycloak server can take care of user management, authentication of users and issuing access tokens and id tokens to registrated clients. The version used for the Teapot project was 20.0 (Quarkus distribution). The Keycloak server was deployed locally in a docker container in dev mode. Keycloak supports different databases to store data, however, the default database (dev-file) was sufficient for the Teapot project. The Keycloak server already contains a \texttt{master realm} with the administrator account. The \texttt{master realm} is the parent of all other realms that can be created by an administrator. For this project, a \texttt{teapot realm} was created. Inside a realm, administrators can create (register)and manage clients and users. The Teapot Gateway needs to be registered as a client in the Teapot realm. When it is created, the client secret is set automatically for the new client, if \texttt{Client authentication} is enabled. This is possible because the Teapot Gateway is a confidential client. The secret is used by the Gateway application when connecting to the Keycloak server to authenticate itself. %With a public client, like a single page application (SPA) or a mobile application, no password should be involved (!!! Quelle aus BA1 raussuchen).%passt eigentlich nicht an diese stelle...

%nicht ganz easy reproduzierbar, evt. hat da nur die falsche adresse mitgespielt, die docker ins hostfile geschrieben hat und es wär sonst nicht so kompliziert gewesen?
For the Teapot project setup where all services are deployed with Docker Compose, the \texttt{Frontend-Url} is set to \texttt{http://host.docker.internal:10001} where the host name is the docker network and the port is the port assigned to Keycloak. If the \texttt{Frontend-Url} is not set explicitly, the host name for the Keycloak endpoints that are used for authentication and authorization flows is set to \texttt{localhost}. Services in other Docker containers access the Keycloak server under it's \texttt{host.docker.internal} url. The frontend-url also determines how the \texttt{iss} claim is set in access tokens, which must be identical with the \texttt{issuer-uri} set at the resource server(!!! Quelle). If \texttt{iss} claim and \texttt{issuer-uri} do not match, the access token does not pass the validation and a \texttt{401} response will be sent back with a remark in the \texttt{XXX-Authenticate} header that the \texttt{iss} claim is not valid (see figure \ref{fig:iss-not-valid-header}).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/iss-not-valid-header}
	\caption{Response header indicating that the \texttt{iss} claim is not valid.}
	\label{fig:iss-not-valid-header}
\end{figure}

All endpoints of the Keycloak server for a realm are accessible under \texttt{<host:port>/realms/<realmname>/.well-known/openid-configuration}. OAuth2 resource servers and clients with the correct \texttt{issuer-uri} can call this endpoint to retrieve the other necessary endpoints, like \texttt{authorization\_endpoint}, \texttt{token\_endpoint}, \texttt{jwks\_uri}, etc., but also other necessary information like supported signing algorithms, grant types, etc. Figure \ref{fig:keycloak-well-known-endpoints} shows the first part of these endpoints.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/keycloak-well-known-endpoints}
	\caption{Keycloak endpoint configuration for the teapot realm (not complete).}
	\label{fig:keycloak-well-known-endpoints}
\end{figure}

% keycloak supports discovery...


% admin console
% realms
% clients
% users
% wie hab ich ihn configuriert?
% Docker compose -> config importiert

\subsection{The Spring Cloud Gateway as OAuth2 Client}
\label{sub:gateway-cl}
%Umbenennen in The Gateway?
The Gateway's job in a MSA is to route requests to services beyond. There is a special Spring Boot starter dependency, \linebreak\texttt{spring-cloud-starter-gateway}, that was used for the implementation of the Teapot project. Maven dependencies are injected in the \linebreak\texttt{pom.xml} file in the following way:

\begin{verbatim}
        	<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
\end{verbatim}

With the Spring Cloud Gateway implemented, a Handler Mapping checks incoming requests for matches with configured routes and if so, forwards them to the Gateway Web Handler. The request then goes through a filterchain where route-specific pre- and post-logic is applied\cite{SpringCloudGatewaya}.

Routes can be configured in the \texttt{application.properties} file or in the \linebreak\texttt{application.yml}. Figure \ref{fig:gateway-route-config} shows an example route configuration from the \texttt{application.yml} file in the reduced Teapot project where no discovery service is used. The \texttt{uri} value is given as an environment variable and will be injected via the docker compose.yml file (!!! see docker). With the Eureka discovery service in the first Teapot, the value would be \texttt{lb://} followed by the name that the Tea service application uses to register with the discovery service. This way the Gateway does not have any need to know the specific current address of the Tea Service or any other application it is routing a request to. The \texttt{Path} predicate defines the path for the endpoint at the gateway. So in this case, requests to \texttt{http://localhost:8181/hellotea/Ula} will be recognized as a match for \texttt{\${TEAS}/teas/hello/Ula}, the path that is set under \texttt{filters} with the \texttt{SetPath}. \texttt{Ula} is an example value for the \texttt{{name}} variable.

\begin{figure}[htbp]
	\centering
		\includegraphics{images/gateway-route-config}
	\caption{Example route configuration from the Gateway's application.yml file in the reduced Teapot project}
	\label{fig:gateway-route-config}
\end{figure}

In order to configure the Gateway as OAuth2 client, we also need to include the \linebreak\texttt{spring-boot-starter-oauth2-client} dependency in the \texttt{pom.xml} file:
\begin{verbatim}
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-client</artifactId>
        </dependency>
\end{verbatim}

Here it is important to choose the correct starter dependency and to not get confused by the different oauth2-client dependencies available, as there are many with similar names. The \linebreak\texttt{spring-boot-starter-oauth2-client} dependency is intended to be used with Spring Boot \cite{GettingStartedSpring}. Then, after having created the client in Keycloak (see section \ref{sub:keycloak}), the application needs to be configured so it can connect to the authorization server and register with the client's credentials. All this is done in the \texttt{application.yml} file (see listing \ref{lst:clientconfig}.
\begin{lstlisting}[frame=lines, caption=OAuth2 client configuration in the Gateway's application.yml file, captionpos=b, label=lst:clientconfig, language=Java, showstringspaces=false]
spring:
[...]
  security:
    oauth2:
      client:
        provider:
          keycloak-provider:
            issuer-uri: ${keycloak.server-url}/realms/teapot
        registration:
          keycloak-gateway-client:
            provider: keycloak-provider
            scope: openid
            client-id: teapot-gateway
            client-secret: ${client-secret}
            authorization-grant-type: authorization_code
            redirect-uri: 'http://localhost:8080/login/oauth2/code/{registrationId}'
\end{lstlisting}

For this purpose we use the \linebreak\texttt{spring.security.oauth2.client.registration} base property prefix, followed by the registration id that will be used by Spring Security's \texttt{OAuth2ClientProperties} class. In this project the client's registration id is \texttt{keycloak-gateway-client}. As explained in section \ref{subsec:oidc}, \texttt{oidc} must be included in the scope claim. Further, the \texttt{client-id} and the \texttt{client-secret}, as well as the \texttt{authorization-grant-type} and the \texttt{redirect-uri} are specified. The \texttt{redirect-uri} is the address that the authorization server will send to the user agent to redirect the user back to the application after authorization has been granted (see section \ref{sec:oauth2}).
The provider section contains the provider name, in this case \texttt{keycloak-provider}. This is the name which the \texttt{registration} section refers to. The \texttt{issuer-uri} must be set correctly, otherwise the application won't be able to start successfully. This also happens when the OIDC provider is not reachable. The reason is, that the issuer-uri is used by the application to retrieve vital configuration metadata from the OIDC provider which is needed for the creation of automatic configuration. As a default, a \texttt{OpenID provider Configuration Request} is made to \texttt{"[specified issuer-uri]/.well-known/openid-configuration"}. This endpoint offers all the necessary configuration metadata, like \texttt{token\_endpoint}, \texttt{jwks\_uri}, \texttt{end\_session\_endpoint}, supported grant types and response types, supported signing and encryption algorithms etc \cite{OpenIDConnectDiscovery}.%in intro verschieben??? dann hier nur verweis

%ist das principal propagation im sinn von yarygina? könnte passen.
The Gateway must also be able to attach access tokens to any authorized request that will be routed to a downstream resource server. Spring Security offers a \texttt{TokenRelayGatewayFilterFactory} which fetches the access token from the authenticated user and attaches an \texttt{Authorization} header to the request with the value \texttt{"Bearer" + token}. The fastest way to add the \texttt{TokenRelayGatewayFilterFactory} is certainly to add a \texttt{default-filter} to the route configuration in the \texttt{application.yml} file as shown in listing \ref{lst:tokenrelay}. This filter will then be applied to all configured routes. Alternatively, the filter can be configured for specific routes by adding \texttt{- TokenRelay=} to \texttt{filters} \cite{TokenRelayGatewayFilterFactory}.

\begin{lstlisting}[frame=lines, caption=Route configuration with token relay default filter in the Gateway's application.yml file, captionpos=b, label = lst:tokenrelay, language=Java, showstringspaces=false]
spring:
  application:
    name: gateway2
  cloud:
    gateway:
      routes:
      
      	[...]

        - id: milk
          uri: ${MILK}
          predicates:
            - Path=/milk
          filters:
            - SetPath=/getmilk

      default-filters:
        - TokenRelay=
\end{lstlisting}

Security configuration for the gateway's endpoints can now be added in the way that is shown in listing \ref{lst:securitywebfilterchain}, taken from the reduced Teapot Gateway2. Because \texttt{/hellogateway} and \texttt{/hellotea/noauth} should remain open for testing purposes, this is taken care for with \texttt{permitAll()} before configuring all remaining endpoints as open for authenticated users only, with \texttt{.authorizeExchange().anyExchange().authenticated()}. With \texttt{oauth2login()} the users will be authenticated so they can have access to the protected endpoints \cite{rozaWebClientOAuth2Support2019}. 
 
\begin{lstlisting}[frame=lines, caption=SecurityWebFilterChain for configuration of the OAuth2 client's behaviour. Code example from the reduced Teapot Gateway2, captionpos=b, label = lst:securitywebfilterchain, language=Java, showstringspaces=false]
@Configuration
@EnableWebFluxSecurity
public class Gateway2SecurityConfiguration {
    @Bean
    public SecurityWebFilterChain springSecurityWebFilterChain(
    			ServerHttpSecurity http,
    			ServerLogoutSuccessHandler handler) {
                .authorizeExchange()
                .pathMatchers("/hellogateway", "/hellotea/noauth")
                .permitAll()
            .and()
                .authorizeExchange()
                .anyExchange()
                .authenticated()
            .and()
                .oauth2Login()
            .and()
                .logout()
                .logoutSuccessHandler(handler);
        return http.build();
    }
\end{lstlisting}

%folgender absatz: ServerlogoutSuccessHander für reactive, LogoutSuccessHandler für servlet... Gateway as Client ist reactive -> ServerLogoutSuccessHandler. teas rs ist servlet, gateway as rs ist auch reactive. lohnt sich teas umschreiben auf reactive noch?
One particular aspect here is the \texttt{logoutSuccessHandler} call that gets an \texttt{ServerLogoutSuccessHandler} object as an argument. A separate bean, as shown in listing \ref{lst:logoutSuccessHandler}, has to be written in order to make this work properly. The \texttt{OidcClientInitiatedServerLogoutSuccessHandler}, which implements the ServerLogoutSuccessHandler interface, takes care of the logout process and calls the Keycloak Server's \texttt{end\_session\_endpoint} for this user \cite{AdvancedConfigurationSpring}, \cite{HowFixKeycloak2022}, \cite{rozaSpringSecurityOpenID2017}. This process is defined in OpenID Connect Session Management 1.0 as the \textit{RP-Initiated Logout}, where RP stands for relying party \cite{jonesOpenIDConnectRPInitiated2022}. Because Keycloak provides Session Management and  Discovery, the \texttt{end\_session\_endpoint} URL can be configured automatically with Spring Boot. The \texttt{postLogoutRedirectUri} is the URI that the user will be redirected to after having logged out successfully. User logout can be initiated by a \texttt{GET} or \texttt{POST} request to \texttt{{base-url}/logout} as default. The \texttt{/logout} endpoint does not need to be permitted explicitly in the filter chain \cite{rozaSpringSecurityOpenID2017}. Figures \ref{fig:logout_requests} and \ref{fig:logout_endsessionurl} show the process in the Firefox networks analytics tool. First, a POST request is sent to the Teapot Gateway's \texttt{logout} endpoint, then a redirect follows to \texttt{http://host.docker.internal:10001/realms/teapot/protocol/openid-connect/logout}, which is the \texttt{end\_session\_endpoint} at the Keycloak, together with the \texttt{id\_token\_hint} and the \texttt{post\_logout\_redirect\_uri} as query parameters. The \texttt{id\_token\_hint} is used to let Keycloak know for which user the session should be cancelled. The \texttt{post\_logout\_redirect\_uri} is open to anonymous users and doesn't require authorization.

%listing: , according to \cite{HowFixKeycloak2022} fehlt!!! einfügen hat probleme gemacht. why?
\begin{lstlisting}[frame=lines, caption=Logout success handler. Code example from the Teapot Gateway according to \cite{rozaSpringSecurityOpenID2017}, captionpos=b, label = lst:securitywebfilterchain, language=Java, showstringspaces=false]
    @Bean
    public ServerLogoutSuccessHandler keycloakLogoutSuccessHandler(ReactiveClientRegistrationRepository repository) {
        OidcClientInitiatedServerLogoutSuccessHandler oidcClientInitiatedServerLogoutSuccessHandler = new OidcClientInitiatedServerLogoutSuccessHandler(repository);
        oidcClientInitiatedServerLogoutSuccessHandler.setPostLogoutRedirectUri("https://orf.at");
        return oidcClientInitiatedServerLogoutSuccessHandler;
    }
\end{lstlisting} 

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/logout_requests}
	\caption{POST request to the \texttt{\\logout} endoint of the Teapot Gateway and redirection to Keycloak's \texttt{end\_session\_endpoint}}
	\label{fig:logout_requests}
\end{figure}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/logout_endsessionurl}
	\caption{The \texttt{end\_session\_endpoint} with query parameters}
	\label{fig:logout_endsessionurl}
\end{figure}


With Spring Boot, a \texttt{GatewayApplication.java} class is created automatically, that contains the \texttt{main} method. With this setup the Gateway application is already fully functional and able to route requests to a resource server together with an access token after the user has authenticated successfully.

An additional feature in the Teapot Gateway is the \texttt{/hellogateway} endpoint which returns a string with a greeting to the user after reading the user's name from the authentication principal . This is possible without adding an additional dependency because \texttt{Spring Cloud Gateway} already contains the \texttt{spring-boot-starter-webflux} dependency.

\begin{lstlisting}[frame=lines, caption=Reading the user's name from the authentication principal., captionpos=b, label = lst:tokenrelay, language=Java, showstringspaces=false]
@RestController
public class GatewayController {
    @GetMapping("/hellogateway")
    public String greet(@AuthenticationPrincipal OAuth2User principal) {
        return "Hello, " + principal.getName() + ", from Gateway";
    }
}
\end{lstlisting}

% \texttt{spring-boot-starter-web} starter dependency also has an automatically embedded TomCat webserver (for reactive web applications there is also the \texttt{spring-boot-starter-webflux} module which comes with Netty as default). - der satz passt hier so nicht, weil gateway ja webflux hat

\subsection{The Resource Server}
\label{sub:gateway-rs}
The OAuth2 Resource Server recieves and validates the access token and, if the token is valid, grants access to the requested resource (see section \ref{sec:oauth2}). The basic steps to configure a resource server with Spring Boot are not very different from the configuration of the OAuth2 client: implementation of the necessary dependencies in the \texttt{pom.xml} file, configuration of the \texttt{issure-uri}, or optionally the \texttt{jwk-set-uri} in \texttt{application.properties} or \texttt{application.properties} and overriding the default \texttt{SecurityFilterChain} with a customized one \cite{wagdeOAuthResourceServer2020}.

The minimal dependencies needed are \texttt{spring-security-oauth2-resource-server}, which contains the resource server support, and \texttt{spring-security-oauth2-jose}, which allows the resource server to decode JWTs, and is therefore crucial for the application's ability to validate JWT access tokens \cite{OAuthResourceServer}. Both are included in the \texttt{spring-boot-starter-oauth2-resource-server} starter dependency. OAuth2 bearer token authentication is possible with JWTs or with opaque tokens (see section \ref{???}). The Teapot project works with JWT.

The authorization process when a request for a protected resource comes in without an access token, goes like this \cite{OAuthResourceServerb}:

\begin{itemize}
\item An unauthenticated request comes in from the User
\item The \texttt{AuthorizationFilter} throws an \texttt{AccessDeniedException}
\item The \texttt{ExceptionTranslationFilter} initiates \textit{Start Authentication} and activates the
\texttt{BearerTokenAuthenticationEntryPoint} to send a \texttt{WWW-Authenticate: Bearer} header (see figure \ref{fig:www-authenticate}
\item Now the client can retry the request with the bearer token.
\end{itemize}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/bearertokenauthenticationenttrypoint}
	\caption{The BearerTokenAuthenticationEntryPoint sends a \texttt{WWW-Authenticate : Bearer} back to the requesting client \cite{BearerTokenAuthenticationEntryPointJava2023}}
	\label{fig:bearertokenauthenticationenttrypoint}
\end{figure}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{images/www-authenticate}
	\caption{\texttt{WWW-Authenticate} header in the response to an unauthorized request to the resource server}
	\label{fig:www-authenticate}
\end{figure}

When the request comes with a bearer token, the \texttt{BearerTokenAuthenticationFilter} extracts the token from the \texttt{HttpServletRequest} and creates a \texttt{BearerTokenAuthenticationToken}, which implements the \texttt{Authentication} interface \cite{BearerTokenAuthenticationTokenSpringsecuritydocsAPI} . The \texttt{Authentication} represents the authenticated user and contains (among others) a \texttt{principal}, which represents an individual, corporation, login id or any other entity \cite{PrincipalJavaDevelopment}, crentials and authorities \cite{AuthenticationSpringsecuritydocsAPI}. An \texttt{authority} is an instance of \texttt{GrantedAuthority} and usually represents coarse-grained permission, for example \texttt{role} or \texttt{scope} \cite{ServletAuthenticationArchitecture} (for more details about the implementation of role-based access control, see section \ref{sub:rbac-impl}). The \texttt{credentials} in this case contain the access token. The \cite{Authentication} is then passed to the \texttt{AuthenticationManager}. The \texttt{AuthenticationManager} is selected by the \texttt{AuthenticationManagerResolver} based on the \texttt{HttpServletRequest}, either for JWT, like in this case, or for opaque tokens. The \texttt{AuthenticationManager} authenticates the \texttt{BearerTokenAuthenticationToken} which means in this case, that it validates the token, stored under \texttt{credentials}. Depending on wheather authentication fails (the token is not valid) or is successfull, the \texttt{SecurityContextHolder} is cleared out and the \texttt{AuthenticationEntryPoint} will send the \texttt{WWW-Authenticate} header again, or the \texttt{SecurityContextHolder} is set the  with the Authentication object and the \texttt{FilterChain} continues \cite{OAuthResourceServerb}.

Like with the OAuth2 client, the resource server needs the \texttt{issuer-uri} to be configured correctly. At startup the resource server application has to deduce the authorization server's configuration endpoint. With only the \texttt{issuer-uri} given, it is important that one of a set of specific configuration endpoints is supported. With the Keycloak server, the configuration endpoint is \texttt{http://localhost:10001/realms/teapot/.well-known/openid-configuration}. This endpoint can now be queried for the \texttt{jwks-url} property and for supported algorithms. With this information, the application can configure the validation strategy which will in the next step query the \texttt{jwks-url} for the public key set of these algorithms. Lastly, the validation strategy will be configured to check the \texttt{iss} claim of recieved JWT access tokens against the given \texttt{issuer-uri}. For this reason the authorization server must be up and reachable, otherwise the resource server application will fail at startup \cite{OAuthResourceServer}.

In order to allow the application to start independently when the authorization server is not yet reachable, the \texttt{jkw-set-uri} can be configured explicitly, because it doesn't need to call the issuer-uri in order to find out the end point to retrieve the JWKS \cite{wagdeOAuthResourceServer2020}. In the Teapot project's \texttt{application.properties} file, this looks like in listing \ref{lst:rs-yml}. Still, with the \texttt{issuer-uri} provided, the \texttt{iss} claim in incoming JWTs will be validated against the given issuer \cite{OAuthResourceServer}.

When a request is sent to a protected endpoint at the resource server, it uses the public key from the authorization server to validate the signature and match it with the token. Then the \texttt{exp} and \texttt{iss} claims in the token are checked \cite{OAuthResourceServer}. For a more differentiated authorization policy it is possible to define scope and roles in Keycloak. In order to use them, custom claims have to be converted into authorities at the resource server (see section \ref{sub:rbac-impl}).

\begin{lstlisting}[style=yaml, frame=lines, caption=\texttt{issuer-uri} and \texttt{jwk-set-uri} in the Tea service's application.properties file, captionpos=b, label=lst:rs-yml, language=Java, showstringspaces=false]
spring:

[...]  

  security:
    oauth2:
      resource-server:
        jwt:
          issuer-uri: ${KEYCLOAK}/realms/teapot
          jwk-set-uri: ${KEYCLOAK}/realms/teapot/protocol/openid-connect/certs
\end{lstlisting}

Like with the client (section {section \ref{sub:gateway-cl}} the \texttt{SecurityFilterChain} bean can be overridden for custom configuration. A minimal configuration of the \texttt{SecurityFilterChain} can look like in listing \ref{lst:rs-secfilterchain}. The two endpoints \texttt{/teas/hello/noauth} and \texttt{/teas/create} are open for convenience during experimental development, while all other endpoints are protected and can only be accessed with a valid access token. \texttt{oauth2ResourceServer} gets a \texttt{Customizer} parameter of type \texttt{OAuth2ResourceServerConfigurer}. With this customizer it is possible to specify that JWT bearer tokens should be supported. This will populate the beforementioned \texttt{BearerTokenAuthenticationFilter} which is responsible for processing the access token \cite{OAuth2ResourceServerConfigurerSpringsecuritydocsAPI}.

\begin{lstlisting}[frame=lines, caption=\texttt{SecurityFilterChain} configuration in the Tea service (resource server), captionpos=b, label = lst:rs-secfilterchain, language=Java, showstringspaces=false]
@Configuration
public class TeaSecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests().requestMatchers("/teas/hello/noauth", "/teas/create").permitAll()
                .anyRequest().authenticated();
        http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
        [...]
        return http.build();
    }
}
\end{lstlisting}

For the definition of authorities that are not provided in the original access token, the customized conversion from the JWT to an \texttt{Authentication} object can be supplied at this point as \texttt{ OAuth2ResourceServerConfigurer.JwtConfigurer.jwtAuthenticationConverter(Converter)} instead of \texttt{OAuth2ResourceServerConfigurer::jwt} \cite{OAuth2ResourceServerConfigurerSpringsecuritydocsAPI}.

Spring Security has CSRF protection enabled by default \cite{SpringBootReferencea}. Because the resource server relies on bearer token authentication, some authors in grey literature recommend making the session stateless  \cite{sandeepaUsingKeycloakSpring2023} and as a consequence to disable CSRF protection \cite{SpringaddonsSamplesTutorials}. This is only possible for resource servers, while clients that are consumed by browsers must always enable CSRF protection because they rely on session cookies \cite{lodderstedtOAuthSecurityBest2023}. This can be configured in the \texttt{SecurityFilterChain} bean as shown in listing \ref{lst:rs-stateless-csrf}.

%hat eigenen yaml-style, siehe ganz oben! farben sind mit kommentaren möglich. linebreak ist dort momentan absichtlich deaktiviert.
\begin{lstlisting}[frame=lines, caption=Stateless session and disabled CSRF protection configured in the\texttt{SecurityFilterChain} bean in the Tea service (resource server), captionpos=b, label = lst:rs-stateless-csrf, language=Java, showstringspaces=false]
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        [...]
        http.sessionManagement((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .csrf().disable();
        return http.build();
    }
\end{lstlisting}

The actual resources that the Tea service is holding are \texttt{Tea} objects that are stored in a MongoDB database. However, the implementation of object relational mapping with spring boot lies beyond the scope of this thesis, therefore further details are omitted.

%!!! Quelle! siehe wfp1 trello, notfalls weglassen, weil eh selbst ausprobiert?
The gateway in a MSA can also be implemented as a resource server instead of being a client. In this case it is necessary that any client sending a request to the gateway is able to provide the appropriate access token because it will not take care of redirecting the user to the OP for authentication. This version has been implemented for the purpose of answering the second research question of this thesis about the positioning of the oauth2 client. The steps to configure the gateway as a client are mostly covered already in this section and in section \ref{sub:gateway-cl} and will therefore be omitted at this point.
% tokenrelay hat hier gestört, nicht klar warum.
% spring cloud gateway kann nur webflux?

\subsection{Role-based access control with Keycloak and Spring Boot Resource Server}
\label{sub:rbac-impl}
In the event that an intruder manages to steal an access token, or if a member of the organization tries to perform operations that they are not entitled to, the possibile damage can be significantly reduced by defining roles with different privileges. In the example of the Teapot this means that someone with a basic user role is not authorized to perform any operation that is not safe, like creating or deleting tea in the database. With a user token, only safe GET requests will be authorized by the resource server. Although this does not mean that no harm can be done by accessing information without altering it, the potential damage is limited compared to a misused access token for Teapot admins, who have privileges that enable them to erase the entire content of the Tea database. Of course this example is highly simplified and in real applications, even a basic user of the system might need to perform operations on the resource that would alter it, or have access to information not intended for anyone else, but the principle remains the same.
%RBAC ist anscheinend ein eigener standard, keine zeit, mich da einzuarbeiten. entweder nur ganz stark vereinfacht, oder so lassen.

Role mapping therefore allows to apply the principle of least privilege (PoLP), which means that users only have the privileges necessary to perform what is inherent to their role, but nothing else (!!! Quelle). Figure \ref{fig:keycloak-client-roles} depicts the roles for the Teapot Gateway client, with their privileges described as defined in the Tea resource server (see listing \ref{lst:roles-secfilterchain}.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-realm-roles}
	\caption{Roles in the Teapot realm with the custom \texttt{tea\_admin} and \texttt{tea\_user} roles.}
	\label{fig:keycloak-realm-roles}
\end{figure}

%Keycloak supports different kinds of access control (ACAB, RBAC, etc.)... https://www.keycloak.org/docs/latest/authorization_services/
With Keycloak there is the option to define realm roles and/or client roles. Realm roles can be composite by being associated to other realm roles or client roles \cite{ServerAdministrationGuide}. Figure \ref{fig:keycloak-client-roles} shows the defined client roles for the Teapot Gateway, while figure \ref{fig:keycloak-realm-admin-associated-roles} shows one of the composite realm roles, \texttt{tea\_admin} and it's associated client roles, \texttt{admin}, \\texttt{user} and \texttt{privileged\_user} which belong to the \texttt{teapot-gateway} client. %realm user ist auch noch dabei

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-client-roles}
	\caption{Example of client roles defined in the Keycloak admin console}
	\label{fig:keycloak-client-roles}
\end{figure}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-realm-admin-associated-roles}
	\caption{Example of a composite realm role and it's associated client role in the Keycloak admin console}
	\label{fig:keycloak-realm-admin-associated-roles}
\end{figure}

Keycloak includes these roles in the access token in a \texttt{realm\_access} or \texttt{resource\_access} claim respectively. The access token for a user with the \texttt{tea\_admin} realm role and the \texttt{admin} client role is shown in figure \ref{fig:keycloak-access-token-aud-roles}. The \texttt{realm\_access} contains only the \texttt{tea\_admin} role (the realm role) and \texttt{resource\_access} contains all associated roles for the \texttt{teapot-client}.

As we can see, the access token does not contain \texttt{authority} claims. The \texttt{realm\_access} or \texttt{resource\_access} access claims are specific to Keycloak (!!! Quelle). Spring Security allows to check for authorities inside the \texttt{authentication} object, but it provides no means by default to check specifically for the access claims provided by a Keycloak access token. This means that these roles have no effect on the authorization process, unless an authority converter is added. A converter translates specific claims in the access token to an \texttt{authority} in order to distinguish roles in authorization. Listing \ref{fig:roles-authorities-converter} shows how the roles can be extracted from the specific claims in the access token. They are returned as a list of authorities and can be checked in the \texttt{SecurityFilterChain} by calling the \texttt{hasAuthority()} method. Spring Security also offers the \texttt{hasRole()} method, which checks for roles specifically. Roles are defined in Spring Security by the \texttt{ROLE\_} prefix !!! Quelle!. This prefix has to be added in the conversion process as well, as shown in listing \ref{fig:roles-authorities-converter}, line 20. Spring Security provides a default \texttt{JwtAuthenticationConverter} for creating a \texttt{Authentication} from a \texttt{JWT}. This converter can be replaced by any class implementing \texttt{Converter<Jwt, AbstractAuthenticationToken>} \cite{OAuthResourceServer}. Listing \ref{lst:roles-converter} shows the custom converter that is used in the Tea resource server. It returns a \texttt{JwtAuthenticationToken} which inherits from \texttt{AbstractOAuth2TokenAuthenticationToken} and contains the extracted realm roles and client roles from the access token as authorities. As it turned out, with the converter code proposed by \cite{ch4mpAnswerUseKeycloak2022} it is important that the profile scope is included in the access token, so that Keycloak will automatically also add further profile information, including the \texttt{preferred\_username} path to the token. As an alternative the try-catch block was added, so that the \texttt{Authentication} is created only with the value of the \texttt{sub} claim.

% !!! für claimpath in access token \cite{ch4mp...}
%		<dependency>
%            <!-- used when converting Keycloak roles to Spring authorities -->
%            <groupId>com.jayway.jsonpath</groupId>
%            <artifactId>json-path</artifactId>
%        </dependency>
        
        
\begin{lstlisting}[frame=lines, caption=Extraction of client roles and realm roles from Keycloak access token and conversion to granted authorities according to \cite{ch4mpAnswerUseKeycloak2022}. Simplified and with addition of the \texttt{ROLE\_} prefix., captionpos=b, label=lst:roles-authorities-converter, language=Java]
@RequiredArgsConstructor
class JwtGrantedAuthoritiesConverter implements Converter<Jwt, Collection<? extends GrantedAuthority>> {

    @Override
    @SuppressWarnings({"rawtypes", "unchecked"})
    public Collection<? extends GrantedAuthority> convert(Jwt jwt) {
        return Stream.of("$.realm_access.roles", "$.resource_access.*.roles").flatMap(claimPaths -> {
                    Object claim;
                    try {
                        claim = JsonPath.read(jwt.getClaims(), claimPaths);
                    } catch (PathNotFoundException e) {
                        return Stream.empty();
                    }
                    final var firstItem = ((Collection) claim).iterator().next();
                    if (firstItem instanceof String) {
                        return (Stream<String>) ((Collection) claim).stream();
                    }
                    if (Collection.class.isAssignableFrom(firstItem.getClass())) {
                        return (Stream<String>) ((Collection) claim).stream().flatMap(item -> ((Collection) item).stream()).map(String.class::cast);
                    }
                    return Stream.empty();
                })
                .map(authority -> new SimpleGrantedAuthority("ROLE_" + authority))
                .map(GrantedAuthority.class::cast).toList();
    }
}
}\end{lstlisting}

\begin{lstlisting}[frame=lines, caption=Custom converter to set the extracted granted authorities from the access token in the new \texttt{Authentication} according to \cite{ch4mpAnswerUseKeycloak2022} with added try/catch blocks, captionpos=b, label= lst:roles-converter, language=Java, showstringspaces=false]
@Component
@RequiredArgsConstructor
class SpringAddonsJwtAuthenticationConverter implements Converter<Jwt, JwtAuthenticationToken> {

    @Override
    public JwtAuthenticationToken convert(Jwt jwt) {
        final var authorities = new JwtGrantedAuthoritiesConverter().convert(jwt);
        final String username;
        try {
            username = JsonPath.read(jwt.getClaims(), "preferred_username");
            return new JwtAuthenticationToken(jwt, authorities, username);
        } catch (PathNotFoundException e) {
            return new JwtAuthenticationToken(jwt, authorities);
        }
    }
}
\end{lstlisting}

The \texttt{SecurityFilterChain} bean can now be overridden in a way that access to different endpoints of the service is granted or not, depending on the role authority extracted from the access token of the user that requests a resource. The custom jwt converter from listing \ref{lst:roles-converter} is given as parameter to the \texttt{oauth2resourceServer} overload method. In listing \ref{lst:roles-secfilterchain}, the \texttt{/teas/admin} endpoint is open for realm admins, while the \texttt{/teas/create} and \texttt{teas/delete/*} endpoints are open for client admins specifically. A user with the realm role \texttt{tea\_admin} has therefore access to all protected endpoints because \texttt{tea\_admin} is a composite role that also contains the three client roles. A user with only the client \texttt{admin} role assigned would not have access to \texttt{/teas/admin}, but can still access other endpoints. Because the client admin is not a composite role, the corresondent authority must be allowed explicitly in addition to the respective user roles (see lines 21-25 in figure \ref{lst:roles-secfilterchain}).%nicht best practice -> hinweis auf acab etc.?

\begin{lstlisting}[frame=lines, caption=, captionpos=b, label=lst:roles-secfilterchain, language=Java, showstringspaces=false]
@RequiredArgsConstructor
@Configuration
@EnableWebSecurity
public class TeaSecurityConfiguration {
    public static final String REALM_ADMIN = "tea_admin";
    public static final String CLIENT_ADMIN = "admin";
    public static final String REALM_USER = "tea_user";
    public static final String CLIENT_USER = "user";
    public static final String CLIENT_PRIVILEGED_USER = "privileged_user";

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, Converter<Jwt, ? extends AbstractAuthenticationToken> jwtAuthenticationConverter) throws Exception {
        http
                .authorizeHttpRequests().requestMatchers("/teas/hello/noauth")
                .permitAll()
                .requestMatchers("/teas/admin")
                .hasRole(REALM_ADMIN)
                .requestMatchers("/teas/create", "/teas/delete/*")
                .hasRole(CLIENT_ADMIN)
                .requestMatchers("/teas/maketea/special")
                .hasAnyRole(CLIENT_PRIVILEGED_USER, CLIENT_ADMIN)
                .requestMatchers("/teas/maketea/*", "/teas/hello/user")
                .hasAnyRole(CLIENT_USER, CLIENT_PRIVILEGED_USER, CLIENT_ADMIN)
                .requestMatchers("/teas/getall")
                .hasAnyRole(REALM_USER, REALM_ADMIN, CLIENT_ADMIN)
            .anyRequest().authenticated();
        http.oauth2ResourceServer().jwt().jwtAuthenticationConverter(jwtAuthenticationConverter);
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
        http.csrf().disable();
        return http.build();
    }
}
\end{lstlisting}

\section{Load testing with JMeter}
\label{sec:loadtesting-jmeter}

To compare the different client positions, load testing was performed for the two variants and for a third version of the Teapot system without any access control, to relate the results. As mentioned before, only the reduced version of the teapot system was involved. The database still exists in the reduced system, but only the "hello"-endpoints were tested without using the database, to avoid unnecessary overhead.

The load testing was performed with Apache JMeter and the services were deployed with docker compose on the same machine. All testing was carried out on a Lenovo Thinkpad T490s with a Intel\textregistered Core\texttrademark  i78665U CPU, 1.9 GHz Base Frequency, 4,8 GHz Max Turbo Frequency and 4 Cores. The operating system was Microsoft Windows 11 Pro.
%heap size... ?

For testing purposes, only the minimal implementation without roles was used and only the gateway was involved, because the process from the moment when the authentication is done and the request is routed to the resource server is the same in all scenarios. Test requests were sent to the gateway's \texttt{/helloauth} endpoint. For authentication in the first case, user login was first triggered via the browser so that the client would send a session cookie to the browser and store the user's access token. This session cookie was extracted and sent with each request to the client-gateway. In the second case, the gateway as resource server expects an access token, so this token was generated with Postman and sent with each request.

Testing parameters were the number of threads (which simulate the number of users), a \textit{ramp-up period} of 0, which means that all threads were started together and a \textit{loop count} of 1, so that each thread will send the request only once. The tests were performed in several rounds for 100 up to 500 concurrent users where 50 users were added to each round. For higher numbers of users a part of the requests started to fail.

For the comparison, the average response times were collected from the HTML dashboard generated by jmeter for each testround.
Load testing results are presented and discussed in section \ref{sec:response-times}.

%\section{Code Analysis - FEHLT}
%\label{code-analysis}
%LoC
%+ Sonarqube Ergebnisse?

\chapter{Results and Discussion} % evt. umbenennen in discussion
\label{chap:results}

!!! ... mir fallt grad nix ein

\section{Compliance with OAuth2 and OIDC specifications}
\label{sec:conformance}

For the implementation presented in chapter \ref{chap:implementation}, functionality and compliance to OAuth2 and OIDC specifications was tested with Postman and Wireshark.

When trying to access the protected resource (the list of available Teas) via the gateway in it's client function at \texttt{http:localhost:8181/listteas} and a Firefox browser as user agent, the following requests and responses could be captured:

\begin{enumerate}
\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET http://localhost:8181/listteas}
\linebreak Unauthenticated user wants to view a list of teas and sends request to dedicated endpoint at the gateway (client)
\linebreak
$\leftarrow$ \texttt{302 Found Location: /oauth2/authorization/keycloak-gateway-client}
\linebreak Gateway refers the user to a different endpoint at the gateway

\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET /oauth2/authorization/keycloak-gateway-client}
\linebreak User agent sends request to the new endpoint
\linebreak
$\leftarrow$ \texttt{302 Found  [truncated]Location: http://host.docker.internal:10001/realms/teapot/protocol/openid-connect/auth...}
\linebreak \texttt{Request URI Query Parameter: response\_type=code}
\linebreak \texttt{Request URI Query Parameter: client\_id=teapot-gateway}
\linebreak \texttt{Request URI Query Parameter: scope=openid}
\linebreak \texttt{Request URI Query Parameter: state=FczD4rvwKxMMyYRC0joaa-oAr-GMbaG2rbuW76gE72k\%3D}
\linebreak \texttt[Request URI Query Parameter: truncated]{redirect\_uri=http://localhost...}
\linebreak \texttt{nonce= omitted by truncation?}
\linebreak Gateway refers user agent to Keycloak's authorization endpoint with the authorization request

\item
\texttt{Source Port: 50966, Dest. Port: 10001
\linebreak $\rightarrow$ [truncated]GET /realms/teapot/protocol/openid-connect/auth...}
\linebreak \texttt{Request URI Query Parameter: response\_type=code}
\linebreak \texttt{Request URI Query Parameter: client\_id=teapot-gateway}
\linebreak \texttt{Request URI Query Parameter: scope=openid}
\linebreak \texttt{Request URI Query Parameter: state=FczD4rvwKxMMyYRC0joaa-oAr-GMbaG2rbuW76gE72k\%3D}
\linebreak \texttt{Request URI Query Parameter: redirect\_uri=http://localhost:8181/login/oauth2/code/keycloak-gateway-client}
\linebreak \texttt{Request URI Query Parameter: nonce=BVUZ0gzd1P-FjEqiFWv8gLspnEEdaOpvvqm3hgiAriI}
\linebreak User agent sends the client's authorization request to Keycloak's authorization endpoint (query parameters omitted)
\linebreak
$\leftarrow$ \texttt{200 OK  (text/html)} (Keycloak Login Form Page)
\linebreak Keycloak responds with the login page to authenticate the user
\linebreak ---Additional requests to load login page omitted---

\item
\texttt{Source Port: 50971, Dest. Port: 10001
\linebreak $\rightarrow$ [truncated]POST /realms/teapot/login-actions/authenticate...}
\linebreak (request query parameters omitted)
\linebreak \texttt{Form item: "username" = "ula"}
\linebreak \texttt{Form item: "password" = "pass"}
\linebreak \texttt{Form item: "credentialId" = ""}
\linebreak User sends login data (username and password in payload)
\linebreak
$\leftarrow$ \texttt{302 Found  [truncated]Location: http://localhost:8181/login/oauth2/code/keycloak-gateway-client...}
\linebreak \texttt{Set-Cookie: KEYCLOAK\_SESSION=teapot/9db57273-f45d-440f-910e-8dc764c3bcb0/4165bd59-749c-4ed3-a210-ecd4a6f928f5; Version=1; Expires=Fri, 16-Jun-2023 22:35:18 GMT; Max-Age=36000; Path=/realms/teapot/; SameSite=None; Secure}
\linebreak (more cookies omitted)
\linebreak
Keycloak sends the user agent back to the gateway with the authorization code and state parameters (see below for full list of parameters)

\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET [truncated]/login/oauth2/code/keycloak-gateway-client...}
\linebreak \texttt{Request URI Query Parameter: state=FczD4rvwKxMMyYRC0joaa-oAr-GMbaG2rbuW76gE72k\%3D}
\linebreak \texttt{Request URI Query Parameter: session\_state=4165bd59-749c-4ed3-a210-ecd4a6f928f5}
\linebreak \texttt{Request URI Query Parameter: code=c49d4ea6-01c0-4f30-8388-48f338bdbd20.4165bd59-749c-4ed3-a210-ecd4a6f928f5.672c0413-eba3-4481-abb5-27f75a71727e}
\linebreak
(User agent sends the code back to the gateway)

\item
\texttt{Source Port: 50976, Dest. Port 10001
\linebreak $\rightarrow$	POST /realms/teapot/protocol/openid-connect/token (application/x-www-form-urlencoded)}
\linebreak \texttt{Authorization: Basic dGVhcG90LWdhdGV3YXk6U2ZBN3RCZFM5V2RrVnozRFlHcG5NOTY3UkFZTUtFU2s}
\linebreak \texttt{Form item: "grant\_type" = "authorization\_code"}
\linebreak \texttt{Form item: "code" = "c49d4ea6-01c0-4f30-8388-48f338bdbd20.4165bd59-749c-4ed3-a210-ecd4a6f928f5.672c0413-eba3-4481-abb5-27f75a71727e"}
\linebreak \texttt{Form item: "redirect\_uri" = "http://localhost:8181/login/oauth2/code/keycloak-gateway-client"}
\linebreak Gateway sends token request to Keykloaks token endpoint, with grant type, code and redirect-uri in the payload
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak \texttt{"access\_token":} (value omitted)
\linebreak \texttt{"expires\_in": "36000"}
\linebreak \textbf{"refresh\_expires\_in": "1800"}
\linebreak \texttt{"refresh\_token":} (value omitted)
\linebreak \texttt{"token\_type": "Bearer"}
\linebreak \texttt{"id\_token":} (value omitted)
\linebreak \texttt{"not-before-policy": "0"}
\linebreak \texttt{"session\_state": "4165bd59-749c-4ed3-a210-ecd4a6f928f5"}
\linebreak \texttt{"scope": openid profile email}
\linebreak Keycloak sends token response (in payload) to the gateway

\item
\texttt{Source Port: 50977, Dest. Port: 10001
\linebreak $\rightarrow$	GET /realms/teapot/protocol/openid-connect/certs}
\linebreak The gateway requests the JWKS from Keycloak
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak Keycloak returns JWKS in payload (omitted)

\item
\texttt{Source Port: 50976, Dest. Port: 10001
\linebreak $\rightarrow$ GET /realms/teapot/protocol/openid-connect/userinfo}
\linebreak \texttt{ [truncated]Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJHV...}
\linebreak Gateway requests additional user information from Keykloak's userinfo endpoint with the freshly issued access token
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak Keycloak returns user info (omitted)


\item
\texttt{Source Port: 8181, Dest. Port: 50965
\linebreak $\leftarrow$ 302 Found Location: /listteas
}
\linebreak Gateway refers user to it's own \texttt{/listteas} endpoint a second time

\item
\texttt{Source Port: 50965, Dest. Port: 8181
\linebreak $\rightarrow$ GET /listteas}
\linebreak Browser sends new request to gateway's \texttt{/listteas} endpoint
\linebreak
$\leftarrow$ 

\item
\texttt{Source Port: 50978, Dest. Port: 8184
\linebreak $\rightarrow$ GET /teas/getall}
\linebreak \texttt{[truncated]Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJHVGZ5e...}
\linebreak Gateway forwards request for list of teas to Tea service with the access token in the \texttt{Authorization} header 
\linebreak
$\leftarrow$ \texttt{200 OK , JavaScript Object Notation (application/json)}
\linebreak
Tea service responds to gateway with list of teas in payload (omitted)

\item
\texttt{Source Port: 8181, Dest. Port: 50965 $\leftarrow$ 200 OK , JavaScript Object Notation (application/json)}
\linebreak Gateway forwards the Tea service's response to the user agent.
\end{enumerate}

The protocol is HTTP 1.1 and host is localhost where not marked differently.

We can see that the steps of the authorization code flow match with the OAuth2 specification. The authorization code is passed through via the user agent to the client who then trades it for the access token with the AZ. Authorization request, token request and token response are present and the access token is passed on from the client to the resource server as bearer token in the \texttt{Authentication} header.

The authorization/authentication request also contains the required parameters \texttt{response\_type}, \texttt{client\_id}, \texttt{redirect\_uri} and \texttt{scope} with \texttt{openid} as the value, where the last two parameters are required by OIDC. The \texttt{code\_challenge} parameter is missing. It is not required when the optional \texttt{nonce} parameter is used, which is the case here, but still recommended by the OAuth2 specification. Also the recommended \texttt{state} parameter is present.

The token request is sent to Keycloak's token endpoint and contains again the \texttt{client\_id} and \texttt{grant\_type} as required. The client authenticates during the token request with basic authentication. This is possibly by definition of OAuth2 and it was a choice during the implementation. However, Spring Security and Keycloak both support other methods of client authentication, for example with a signed JWT \cite{AuthorizationServicesGuide}, \cite{ClientAuthenticationSupport}. The value in the authorization header is the base64-encoding of \texttt{client\_id:client\_secret}.

The token response also contains all required parameters, including the id token, since it is an OIDC token response. The \texttt{scope} parameter contains more scope strings than the requested \texttt{oidc} scope and is therefore required as well \cite{hardtOAuthAuthorizationFramework2023}. Other parameters are specific to Keycloak and are not covered in the specifications. The access token lifetime was intentionally configured to be longer than recommended for testing convenience.

The access token itself turned out to show some flaws. In the Wireshark capture shown above it is truncated and can not be anaylzed, however when examining other access tokens issued by Keycloak, some faults become apparent: the media type in the \texttt{typ} header parameter is not \texttt{at+jwt} or \texttt{application/at+jwt} as required for OAuth2 JWT tokens. This special value is important for the distinction between access tokens and id tokens, to avoid that id tokens are accepted as access tokens \cite{bertocciJSONWebToken2021}. In fact, the attempt to request Tea from the Tea service with the id token instead of an access token was successful with this implementation (without role mapping). No configuration option could be found for Keycloak to change the token header, neither in the documentation nor by browsing through Keycloaks admin console. This does not mean that it is not possible, but it can be criticized that it is not as straightforward as it should be and the question remains why the required media type is not the default. As long as the access token's media type can not be changed, implementing it's validation on the resource server would not make sense. A related problem is the missing \texttt{aud} claim in the access token, which must be validated by the resource server, who must reject the request if it can not identify itself with the value \cite{bertocciJSONWebToken2021}. The \texttt{aud} claim can be set and configured in the Keycloak admin console by adding a scope mapper of the \textit{Audience} type \cite{•}. Token validation with Spring Security can be configured with the \texttt{OAuth2TokenValidator} API \cite{OAuthResourceServer}. At the Tea service, this would look like shown in listing \ref{lst:aud-validation}. An example access token which now includes the required \texttt{aud} claim is shown in figure \ref{fig:keycloak-access-token-aud-roles}. Another required parameter not included by Keycloak by default is \texttt{client\_id}. Adding it to the token with a scope mapper can be done in a similar way as for the \texttt{aud} claim, although Keycloak doesn't seem to offer a preconfigured mapper for this purpose. However, the \texttt{azp} claim does indeed contain the client id by default and seems to fulfil a similar purpose.

\begin{lstlisting}[frame=lines, caption=Validator for the \texttt{aud} claim for the Tea resource server according to \cite{OAuthResourceServer}., captionpos=b, label = lst:aud-validation, language=Java, showstringspaces=false]
OAuth2TokenValidator<Jwt> audienceValidator() {
    return new JwtClaimValidator<List<String>>(AUD, aud -> aud.contains("tea"));
}
\end{lstlisting}

%scope strings must have meaning for resource in the aud claim -> not implemented

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-access-token-aud-roles}
	\caption{Example of an access token issued by the Keycloak server.}
	\label{fig:keycloak-access-token-aud-roles}
\end{figure}

The id token issued by Keycloak is inconspicuous in comparison. An example id token with additional user information is shown in figure \ref{fig:keycloak-id-token}. Including user profile information or roles in the id token is optional and can be configured in the Keycloak admin console. The same is true for the information returned by the userInfo endpoint.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/keycloak-id-token}
	\caption{Example of an id token issued by the Keycloak server.}
	\label{fig:keycloak-id-token}
\end{figure}


%!!! Keycloak (in der 20er version) und Spring Security unterstützen immer noch deprecated grant types! 

%refresh token auslassen weil komplett optional und nicht weiter genutzt.

% error responses weglassen!

%!!! besser nicht 100% vollständig! es kann auch einfach erwähnt werden, was getestet wurde und ob error responses entsprechen



%session\_state ist teil vom KEYCLOAK\_SESSION  cookie

%implementation: schwierig wegen deprecation (spring boot3, spring security, keycloak adapter) und nicht mehr aktuellen tutorials und documentations -> keycloak war am anfang noch am übergang und doc nicht up to date

%scaling: api gateway has the potential to become a bottleneck \cite{matarApproachEvaluatingPotential2023}  -> bff can mitigate this to a certain degree by desing by having several gateways, but also a basic API gateway should be duplicated at some point.

\section{Response times} % raufverschieben zu implementation
\label{sec:response-times}

!!! tests für die ganze runde fehlen! + erklären, was beim jeweiligen szenario passiert.
etwas andere parameter weil client nur in der gui mit 0 ramp up time testbar war

Load testing of the different gateway variants showed a tendency toward higher average response times at the gateway as resource server in comparison to the gateway as client. The response times for the unprotected gateway were generally lower than the other two gateways, which can be expected because no endpoint protection mechanism is involved in the process. Figure \ref{fig:response-times-hellotea} shows the average response times for all three variants.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\linewidth]{images/response-times-hellotea}
	\caption{Average response times in milliseconds of the \texttt{/helloauth} endpoint of all three gateway variants.}
	\label{fig:response-times-hellotea}
\end{figure}

The load testing experiment was repeated several times. Although the resulting numbers were not always the same as in the graph depicted in figure \ref{fig:response-times}, they showed consistently that the gateway has longer response times when it is implemented as resource server than in it's client implementation. The diference betwen the two gateways is that the gateway as resource server recieves the access token, checks it's validity and routes it forward with the request, while the client-gateway recieves a session cookie that will be matched with the one stored for the user agent. It then takes the access token that it associates with the authenticated user and routes it with the user's request to the resource server. It does not have to read the access token for that purpose. The effect might even be stronger with a more thorough examination of the access token, when more parameters have to be checked before the token is accepted. Additionally, a frontend application that consumes the gateway's endpoints has to implement client functionality which includes occasional communication with the AZ, when the gateway is a resource server, which can only add to the total delay from the user's perspective.

%A closer look at the results report generated by JMeter for the single testrounds revealed that the number of concurrent threads was always lower in the report than the number of concurrently started threads in the setup. For example, When the load test was set up for 100 threads, with a ramp-up time of 0, only 70 concurrent threats were reached according to the report and between 275 and close to 400 threads in the report for a setup with 500 threads. Also, the reports show average response times for the number of concurrent threads during a single test round, which did not grow as expected with the number of concurrent threads, but had a tendency to get lower. Different parameters were tested and did not change this behaviour. Timestamps and the \texttt{allThreads} column in the \texttt{.jtl} results file for the load tests suggest that the number of concurrent threads indicates the number of threads still running at the time when the response is recieved.

%!!! Wenn alles nach best practice implementiert ist, könnte es sein, dass die zeiten nicht mehr in der reihenfolge liegen
%scaling...
%welche art von authentication zwischen gateway als rs und tea rs, könnte auch mtls sein z.B.

%\section{Code complexity - FEHLT}
%\label{complexity}

\chapter{Conclusion and Future Work}
\label{chap:conclusion}

In this thesis it has been investigated how authentication and authorization can be implemented in a MSA system according to OAuth2 and OIDC specifications, using Spring Boot and Keycloak. The outcome was analyzed with Firefox, Postman and Wireshark to check, if the implementation complies with the specification and where further improvement is necessary. The results of this investigation made apparent that most basic requirements can be fulfilled with very few configuration steps in the Keycloak admin console, such as creating a realm, a client and a user, and by overriding the \texttt{SecurityFilterChain} in the source code of the resource server and the client (when implemented as part of the MSA). While some requirements were omitted by choice, for convenience during the development process, like not protecting communication between services with TLS, the absence of some other required features, like certain token claims and their validation, was revealed only upon further analysis of the generated requests and responses between the services. While it was possible to gather information about how to implement some of them, this was not the case for the wrong media type (\texttt{JWT} instead of \texttt{at+jwt}) in the \texttt{typ} header value of access tokens issued by Keycloak. As long as the media type can not be distinguished from the media type of id tokens, a check for the correct \texttt{typ} header value, which is required by RFC 9068, can not be implemented in the resource server without making it unfunctional.

Additionally, logout functionality was implemented, which is not defined in OAuth2 and only mentioned as optional in the OIDC core specification, therefore adherence to the specifications \cite{!!! https://openid.net/specs/openid-connect-session-1_0.html zotero hat gestreikt} was not analyzed. This could be a possible extension of this research.

Another not strictly required feature that was implemented is access control based on user roles, because having at least a minimum of differentiated access control is considered best practice for better security. Keycloak supports other, more fine-grained methods of access control, like attribute-based access control (ACAB), but the implementation, but the limitation on roles seemes sufficient as a proof of concept within the scope of this thesis. The implementation of ACAB can also be a suggestion for future work.

!!! Kürzen weil jetzt im intro! trial and error kann bleiben! Gathering the necessary information for these further implementations was not always an easy task. One reason was the unfortunate timing of this research which started only a couple of months after the Keycloak adapters for Spring Boot had been deprecated in early 2022 \cite{DeprecationKeycloakAdapters}. These adapters had been in use for some years and most of the information and examples that were available online still referred to the usage of the Keycloak adapter, including the Keycloak documentation. A lot of trial and error experimentation was involved to find the correct configurations and it can be assumed that the presented state of implementation and configuration of the Teapot system can still be improved.

It is also clear that this thesis, while paying close attention to many details in the specifications was not sufficient to cover all the requirements in detail as it would be necessary for a secure production-ready implementation, not to mention recommendations and best practice. The presented implementation and considerations therefore cover only a selection, which leaves the implementation and analysis of further details for future work. Examples are using a recommended client authentication method like mTLS or JWT, using sender-constrained access tokens, using code challenge/PKCE in the authorization code flow and of course client communication must be secured with TLS (required by OAuth2).

Another suggestion for future work would be a more thorough and systematic security testing of the implementation. While some tests were performed manually, like using the id token as access token, manipulating the payload of the access token or sending invalid parameters in the authorization or token request, protection against other attacks was not tested systematically. The OAuth2 specification includes a list of threats and possible attacks and information about their mitigation.

The second part of the investivation was a comparison of average response times between different implementations of the gateway, as a client and as an additional resource server, which requires the frontend application to implement client functionality. Several test rounds of load testing for different numbers of concurrent users showed that the client-gateway was faster than it's resource server. While the more common interpretation seems to be that client in the OAuth2 terminology equals the frontend, this outcome can be interpreted as a challenge to the traditional assumption. However, more investigations and considerations are necessary to make a clear statement. Load testing could also be performed for higher numbers of concurrent users and security checks are necessary. It is possible that the client-gateway version requires additional measurements to secure the communication between frontend and gateway.

\newpage
% --- Bibliography ------------------------------------------------------

%IEEE Citation [1]
\bibliographystyle{IEEEtran}
%for alphanumeric citation eg.: [ABC19]
%\bibliographystyle{alpha}

% List references I definitely want in the bibliography,
% regardless of whether or not I cite them in the thesis.

\newpage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{BA2}

\newpage

% --- List of Figures ----------------------------------------------------

\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures

% --- List of Code Listings ----------------------------------------------------

\addcontentsline{toc}{chapter}{List of Code Listings}
\lstlistoflistings

% --- List of Tables -----------------------------------------------------

\newpage
\addcontentsline{toc}{chapter}{List of Tables}
\listoftables

\end{document}
